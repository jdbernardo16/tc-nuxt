import { useNuxt, extendPages, defineNuxtModule, createResolver, useLogger, addPlugin, addServerHandler, hasNuxtModule, hasNuxtModuleCompatibility } from '@nuxt/kit';
import { useSiteConfig, installNuxtSiteConfig } from 'nuxt-site-config/kit';
import { readPackageJSON } from 'pkg-types';
import { existsSync } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
import { onDevToolsInitialized, extendServerRpc } from '@nuxt/devtools-kit';
import { diffArrays } from 'diff';
import { resolve, relative } from 'pathe';
import { generateLinkDiff } from '../dist/runtime/shared/diff.js';
import { joinURL, withoutLeadingSlash } from 'ufo';
import chalk from 'chalk';
import { load } from 'cheerio';
import Fuse from 'fuse.js';
import { createStorage } from 'unstorage';
import fsDriver from 'unstorage/drivers/fs';
import { setLinkResponse, getLinkResponse, crawlFetch } from '../dist/runtime/shared/crawl.js';
import { inspect } from '../dist/runtime/shared/inspect.js';
import { createFilter } from '../dist/runtime/shared/sharedUtils.js';

function convertNuxtPagesToPaths(pages) {
  return pages.map((page) => {
    return page.children?.length ? page.children.map((child) => {
      return {
        path: joinURL(page.path, child.path),
        page: child
      };
    }) : { page, path: page.path };
  }).flat().filter((p) => !p.path.includes(":")).map((p) => ({
    title: p.page?.meta?.title || "",
    link: p.path
  }));
}
function useViteWebSocket(nuxt = useNuxt()) {
  return new Promise((_resolve) => {
    nuxt.hooks.hook("vite:serverCreated", (viteServer) => {
      _resolve(viteServer.ws);
    });
  });
}

const DEVTOOLS_UI_ROUTE = "/__nuxt-link-checker";
const DEVTOOLS_UI_LOCAL_PORT = 3030;
const RPC_NAMESPACE = "nuxt-link-checker-rpc";
function setupDevToolsUI(options, moduleResolve, nuxt = useNuxt()) {
  const clientPath = moduleResolve("./client");
  const isProductionBuild = existsSync(clientPath);
  if (isProductionBuild) {
    nuxt.hook("vite:serverCreated", async (server) => {
      const sirv = await import('sirv').then((r) => r.default || r);
      server.middlewares.use(
        DEVTOOLS_UI_ROUTE,
        sirv(clientPath, { dev: true, single: true })
      );
    });
  } else {
    nuxt.hook("vite:extendConfig", (config) => {
      config.server = config.server || {};
      config.server.proxy = config.server.proxy || {};
      config.server.proxy[DEVTOOLS_UI_ROUTE] = {
        target: `http://localhost:${DEVTOOLS_UI_LOCAL_PORT}${DEVTOOLS_UI_ROUTE}`,
        changeOrigin: true,
        followRedirects: true,
        rewrite: (path) => path.replace(DEVTOOLS_UI_ROUTE, "")
      };
    });
  }
  nuxt.hook("devtools:customTabs", (tabs) => {
    tabs.push({
      // unique identifier
      name: "nuxt-link-checker",
      // title to display in the tab
      title: "Link Checker",
      // any icon from Iconify, or a URL to an image
      icon: "carbon:cloud-satellite-link",
      // iframe view
      view: {
        type: "iframe",
        src: DEVTOOLS_UI_ROUTE
      }
    });
  });
  let isConnected = false;
  const viteServerWs = useViteWebSocket();
  const rpc = new Promise((promiseResolve) => {
    onDevToolsInitialized(async () => {
      const rpc2 = extendServerRpc(RPC_NAMESPACE, {
        getOptions() {
          return options;
        },
        async reset() {
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:reset");
        },
        async scrollToLink(link) {
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:scroll-to-link", link);
        },
        async applyLinkFixes(diff, original, replacement) {
          for (const { filepath } of diff) {
            const rootDirFolderName = nuxt.options.rootDir.split("/").pop();
            const filepathWithoutRoot = filepath.replace(new RegExp(`^${nuxt.options.rootDir}/`), "").replace(new RegExp(`^${rootDirFolderName}/`), "");
            const fp = resolve(nuxt.options.rootDir, filepathWithoutRoot);
            const contents = await readFile(fp, "utf8");
            const diff2 = generateLinkDiff(contents, original, replacement);
            await writeFile(fp, diff2.code, "utf8");
          }
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:reset");
        },
        async toggleLiveInspections(enabled) {
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:live-inspections", { enabled });
        },
        async connected() {
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:connected");
          isConnected = true;
        }
      });
      promiseResolve(rpc2);
    });
  });
  viteServerWs.then((ws) => {
    ws.on("nuxt-link-checker:queueWorking", async (payload) => {
      if (isConnected) {
        const _rpc = await rpc;
        _rpc.broadcast.queueWorking(payload).catch(() => {
        });
      }
    });
    ws.on("nuxt-link-checker:updated", async () => {
      if (isConnected) {
        const _rpc = await rpc;
        _rpc.broadcast.updated().catch(() => {
        });
      }
    });
    ws.on("nuxt-link-checker:filter", async (payload) => {
      if (isConnected) {
        const _rpc = await rpc;
        _rpc.broadcast.filter(payload).catch(() => {
        });
      }
    });
    let lastRoutes = [];
    extendPages(async (pages) => {
      const routes = convertNuxtPagesToPaths(pages);
      if (lastRoutes.length) {
        const routeDiff = diffArrays(lastRoutes, routes);
        if (routeDiff.some((diff) => diff.added || diff.removed))
          ws.send("nuxt-link-checker:reset");
      }
      lastRoutes = routes;
    });
  });
}

const linkMap = {};
function extractPayload(html, rootNodeId = "#__nuxt") {
  if (String(rootNodeId).length) {
    rootNodeId = rootNodeId[0] === "#" ? rootNodeId : `#${rootNodeId}`;
  }
  const $ = load(html);
  const ids = $(`${rootNodeId} [id]`.trim()).map((i, el) => $(el).attr("id")).get();
  const title = $("title").text();
  const links = $(`${rootNodeId} a`.trim()).map((i, el) => {
    return {
      role: $(el).attr("role") || "",
      link: $(el).attr("href") || "",
      textContent: ($(el).attr("aria-label") || $(el).attr("title") || $(el).text()).trim() || ""
    };
  }).get();
  return { title, ids, links };
}
function isNuxtGenerate(nuxt = useNuxt()) {
  return nuxt.options._generate || nuxt.options.nitro.static || nuxt.options.nitro.preset === "static";
}
function prerender(config, nuxt = useNuxt()) {
  const urlFilter = createFilter({
    exclude: config.excludeLinks
  });
  nuxt.hooks.hook("nitro:init", async (nitro) => {
    const siteConfig = useSiteConfig();
    nitro.hooks.hook("prerender:generate", async (ctx) => {
      const route = decodeURI(ctx.route);
      if (ctx.contents && !ctx.error && ctx.fileName?.endsWith(".html") && !route.endsWith(".html") && urlFilter(route))
        linkMap[route] = extractPayload(ctx.contents, nuxt.options.app.rootAttrs?.id || "");
      setLinkResponse(route, Promise.resolve({ status: Number(ctx.error?.statusCode) || 200, statusText: ctx.error?.statusMessage || "", headers: {} }));
    });
    nitro.hooks.hook("prerender:done", async () => {
      const payloads = Object.entries(linkMap);
      if (!payloads.length)
        return;
      const storageFilepath = typeof config.report?.storage === "string" ? resolve(nuxt.options.rootDir, config.report?.storage) : nitro.options.output.dir;
      const storage = createStorage(config.report?.storage && typeof config.report.storage !== "string" ? config.report?.storage : {
        driver: fsDriver({
          base: storageFilepath
        })
      });
      const links = payloads.map(([route, payload]) => {
        return {
          path: route,
          title: payload.title
        };
      }).flat();
      const pageSearcher = new Fuse(links, {
        keys: ["path", "title"],
        threshold: 0.5
      });
      nitro.logger.info("Running link inspections...");
      let routeCount = 0;
      let errorCount = 0;
      const allReports = (await Promise.all(payloads.map(async ([route, payload]) => {
        const reports = await Promise.all(payload.links.map(async ({ link, textContent }) => {
          if (!urlFilter(link) || !link)
            return { error: [], warning: [], link };
          const response = await getLinkResponse({
            link,
            timeout: config.fetchTimeout,
            fetchRemoteUrls: config.fetchRemoteUrls,
            isInStorage() {
              return existsSync(resolve(nuxt.options.rootDir, nuxt.options.dir.public, withoutLeadingSlash(link)));
            }
          });
          return inspect({
            ids: linkMap[route].ids,
            fromPath: route,
            pageSearch: pageSearcher,
            siteConfig,
            link,
            textContent,
            response,
            skipInspections: config.skipInspections
          });
        }));
        const errors = reports.filter((r) => r.error?.length).length;
        errorCount += errors;
        const warnings = reports.filter((r) => r.warning?.length).length;
        if (errors || warnings) {
          const statusString = [
            errors > 0 ? chalk.red(`${errors} error${errors > 1 ? "s" : ""}`) : false,
            warnings > 0 ? chalk.yellow(`${warnings} warning${warnings > 1 ? "s" : ""}`) : false
          ].filter(Boolean).join(chalk.gray(", "));
          nitro.logger.log(chalk.gray(
            `  ${Number(++routeCount) === payload.links.length - 1 ? "\u2514\u2500" : "\u251C\u2500"} ${chalk.white(route)} ${chalk.gray("[")}${statusString}${chalk.gray("]")}`
          ));
          reports.forEach((report) => {
            if (report.error?.length || report.warning?.length) {
              nitro.logger.log(chalk.dim(`    ${report.textContent} ${report.link}`));
              report.error?.forEach((error) => {
                nitro.logger.log(chalk.red(`        \u2716 ${error.message}`) + chalk.gray(` (${error.name})`));
                if (error.fix)
                  nitro.logger.log(chalk.gray(`          ${error.fixDescription}`));
              });
              report.warning?.forEach((warning) => {
                nitro.logger.log(chalk.yellow(`        \u26A0 ${warning.message}`) + chalk.gray(` (${warning.name})`));
                if (warning.fix)
                  nitro.logger.log(chalk.gray(`          ${warning.fixDescription}`));
              });
            }
          });
        }
        return { route, reports };
      }))).flat();
      const reportsWithContent = allReports.filter(({ reports }) => reports.some((r) => r.error?.length || r.warning?.length));
      if (config.report?.html) {
        const reportHtml = reportsWithContent.map(({ route, reports }) => {
          const reportsHtml = reports.map((r) => {
            const errors2 = r.error?.map((error) => {
              return `<li class="error">${error.message} (${error.name})</li>`;
            }) || [];
            const warnings2 = r.warning?.map((warning) => {
              return `<li class="warning">${warning.message} (${warning.name})</li>`;
            }) || [];
            const valid = errors2.length + warnings2.length === 0;
            return `<li class="link"><a href="${r.link}">${r.link}</a>${!valid ? `<ul>${[...errors2, ...warnings2].join("\n")}</ul>` : "Valid"}</li>`;
          }).join("\n");
          const errors = reports.filter((r) => r.error?.length).length;
          const warnings = reports.filter((r) => r.warning?.length).length;
          const statusString = [
            errors > 0 ? `${errors} error${errors > 1 ? "s" : ""}` : false,
            warnings > 0 ? `${warnings} warning${warnings > 1 ? "s" : ""}` : false
          ].filter(Boolean).join(", ");
          return `
            <h2><a href="${route}">${route}</a> ${statusString}</h2>
            <ul>
              ${reportsHtml}
            </ul>
            `;
        }).join("");
        const html = `
                <html>
                    <head>
                    <title>Link Checker Report</title>
                    <style>
                        body {
                        font-family: sans-serif;
                        }
                        .link {
                        margin-bottom: 1rem;
                        }
                        /* use a modern, tailwind colour pallet for .error and .warning, do not use red or yellow */
                        .error {
                            color: #F87171;
                        }
                        .warning {
                            color: #FBBF24;
                        }
                    </style>
                    </head>
                    <body>
                    <h1>Link Checker Report</h1>
                    <ul>
                        ${reportHtml}
                    </ul>
                    </body>
                </html>
                `;
        await storage.setItem("link-checker-report.html", html);
        if (storageFilepath) {
          nitro.logger.info(`Nuxt Link Checker HTML report written to ./${relative(nuxt.options.rootDir, resolve(storageFilepath, "link-checker-report.html"))}`);
        }
      }
      if (config.report?.markdown) {
        const reportMarkdown = reportsWithContent.map(({ route, reports }) => {
          const reportsMarkdown = reports.map((r) => {
            const errors2 = r.error?.map((error) => {
              return `| ${r.link} | ${error.message} (${error.name}) |`;
            }) || [];
            const warnings2 = r.warning?.map((warning) => {
              return `| ${r.link} | ${warning.message} (${warning.name}) |`;
            }) || [];
            return [...errors2, ...warnings2].filter(Boolean);
          }).flat().filter(Boolean).join("\n");
          const errors = reports.filter((r) => r.error?.length).length;
          const warnings = reports.filter((r) => r.warning?.length).length;
          const statusString = [
            errors > 0 ? `${errors} error${errors > 1 ? "s" : ""}` : false,
            warnings > 0 ? `${warnings} warning${warnings > 1 ? "s" : ""}` : false
          ].filter(Boolean).join(", ");
          return [
            `## [${route}](${route}) ${statusString}`,
            "| Link | Message |",
            "| --- | --- |",
            reportsMarkdown,
            ""
          ].join("\n");
        }).join("\n");
        const markdown = [
          "# Link Checker Report",
          "",
          reportMarkdown
        ].join("\n");
        await storage.setItem("link-checker-report.md", markdown);
        if (storageFilepath) {
          nitro.logger.info(`Nuxt Link Checker Markdown report written to ./${relative(nuxt.options.rootDir, resolve(storageFilepath, "link-checker-report.md"))}`);
        }
      }
      if (config.report?.json) {
        const json = JSON.stringify(reportsWithContent, null, 2);
        await storage.setItem("link-checker-report.json", json);
        if (storageFilepath) {
          nitro.logger.info(`Nuxt Link Checker JSON report written to ./${relative(nuxt.options.rootDir, resolve(storageFilepath, "link-checker-report.json"))}`);
        }
      }
      if (errorCount > 0 && config.failOnError) {
        nitro.logger.error(`Nuxt Link Checker found ${errorCount} errors, failing build.`);
        nitro.logger.log(chalk.gray('You can disable this by setting "linkChecker: { failOnError: false }" in your nuxt.config.'));
        process.exit(1);
      }
    });
  });
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-link-checker",
    compatibility: {
      nuxt: ">=3.9.0",
      bridge: false
    },
    configKey: "linkChecker"
  },
  defaults: {
    strictNuxtContentPaths: false,
    fetchRemoteUrls: false,
    // provider !== 'stackblitz',
    runOnBuild: true,
    debug: false,
    showLiveInspections: false,
    enabled: true,
    fetchTimeout: 1e4,
    failOnError: false,
    excludeLinks: [],
    skipInspections: []
  },
  async setup(config, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const logger = useLogger("nuxt-link-checker");
    logger.level = config.debug || nuxt.options.debug ? 4 : 3;
    const { name, version } = await readPackageJSON(resolve("../package.json"));
    if (config.enabled === false) {
      logger.debug(`The ${name} module is disabled, skipping setup.`);
      return;
    }
    await installNuxtSiteConfig();
    if (config.fetchRemoteUrls) {
      config.fetchRemoteUrls = (await crawlFetch("https://google.com")).status === 200;
      if (!config.fetchRemoteUrls)
        logger.warn("Remote URL fetching is disabled because you appear to be offline.");
    }
    const isDevToolsEnabled = typeof nuxt.options.devtools === "boolean" ? nuxt.options.devtools : nuxt.options.devtools.enabled;
    if (nuxt.options.dev && isDevToolsEnabled !== false) {
      addPlugin({
        src: resolve("./runtime/app/plugins/ui.client"),
        mode: "client"
      });
      addServerHandler({
        route: "/__link-checker__/inspect",
        handler: resolve("./runtime/server/routes/__link-checker__/inspect")
      });
      addServerHandler({
        route: "/__link-checker__/links",
        handler: resolve("./runtime/server/routes/__link-checker__/links")
      });
      addServerHandler({
        route: "/__link-checker__/debug.json",
        handler: resolve("./runtime/server/routes/__link-checker__/debug")
      });
      const pagePromise = new Promise((_resolve) => {
        extendPages((pages) => {
          _resolve(pages);
        });
      });
      nuxt.hooks.hook("nitro:config", (nitroConfig) => {
        nitroConfig.virtual["#nuxt-link-checker-sitemap/pages.mjs"] = async () => {
          const pages = await pagePromise;
          return `export default ${JSON.stringify(convertNuxtPagesToPaths(pages), null, 2)}`;
        };
      });
      const hasSitemapModule = (hasNuxtModule("@nuxtjs/sitemap") || hasNuxtModule("nuxt-simple-sitemap") && await hasNuxtModuleCompatibility("nuxt-simple-sitemap", ">=4")) && nuxt.options.sitemap?.enabled !== false;
      nuxt.options.nitro.alias = nuxt.options.nitro.alias || {};
      if (!hasNuxtModule("@nuxt/content")) {
        nuxt.options.nitro.alias["#content/server"] = resolve("./runtime/server/composables/content-mock");
      }
      nuxt.options.alias["#link-checker"] = resolve("./runtime");
      nuxt.options.runtimeConfig.public["nuxt-link-checker"] = {
        version,
        hasSitemapModule,
        rootDir: nuxt.options.rootDir,
        // @ts-expect-error untyped
        isNuxtContentDocumentDriven: config.strictNuxtContentPaths || hasNuxtModule("@nuxt/content") && nuxt.options.content?.documentDriven,
        excludeLinks: config.excludeLinks,
        skipInspections: config.skipInspections,
        fetchTimeout: config.fetchTimeout,
        showLiveInspections: config.showLiveInspections,
        fetchRemoteUrls: config.fetchRemoteUrls
      };
      setupDevToolsUI(config, resolve);
    }
    if (config.runOnBuild) {
      const isRenderingAllRoutes = isNuxtGenerate(nuxt) && !nuxt.options.nitro.prerender?.crawlLinks;
      if (!nuxt.options._prepare && !nuxt.options.dev && nuxt.options.build && !isRenderingAllRoutes) {
        config.skipInspections.push("no-error-response");
      }
      prerender(config);
    }
  }
});

export { module as default };
