import { serverQueryContent } from "#content/server";
import { useNitroOrigin, useRuntimeConfig, useSiteConfig } from "#imports";
import { generateFileLinkDiff, generateFileLinkPreviews, getLinkResponse, inspect, isNonFetchableLink, lruFsCache } from "#link-checker/shared";
import Fuse from "fuse.js";
import { defineEventHandler, getHeader, readBody } from "h3";
import { fixSlashes } from "nuxt-site-config/urls";
import { resolve } from "pathe";
import { parseURL } from "ufo";
function isInternalRoute(path) {
  const lastSegment = path.split("/").pop() || path;
  return lastSegment.includes(".") || path.startsWith("/__") || path.startsWith("@");
}
export default defineEventHandler(async (e) => {
  const { tasks, ids } = await readBody(e);
  const runtimeConfig = useRuntimeConfig().public["nuxt-link-checker"] || {};
  const partialCtx = {
    ids,
    fromPath: fixSlashes(false, parseURL(getHeader(e, "referer") || "/").pathname),
    siteConfig: useSiteConfig(e)
  };
  const extraPaths = [];
  if (serverQueryContent) {
    const contentDocument = await serverQueryContent(e, partialCtx.fromPath).findOne();
    if (contentDocument)
      extraPaths.push(resolve(runtimeConfig.rootDir, "content", contentDocument._file));
  }
  lruFsCache.clear();
  const links = await $fetch("/__link-checker__/links");
  return Promise.all(
    tasks.map(async ({ link, paths, textContent }) => {
      if (isNonFetchableLink(link) || isInternalRoute(link))
        return { passes: true };
      const response = await getLinkResponse({
        link,
        timeout: runtimeConfig.fetchTimeout,
        fetchRemoteUrls: runtimeConfig.fetchRemoteUrls,
        baseURL: useNitroOrigin(e),
        isInStorage() {
          return false;
        }
      });
      const result = inspect({
        ...partialCtx,
        link,
        textContent,
        pageSearch: new Fuse(links, {
          keys: ["path", "title"],
          threshold: 0.5
        }),
        response,
        skipInspections: runtimeConfig.skipInspections
      });
      const filePaths = [
        ...extraPaths,
        ...paths.map((p) => {
          const [filepath] = p.split(":");
          return filepath;
        })
      ];
      if (!result.passes) {
        result.sources = (await Promise.all(filePaths.map(async (filepath) => await generateFileLinkPreviews(filepath, link)))).filter((s) => s.previews.length);
        result.diff = await Promise.all((result.sources || []).map(async ({ filepath }) => generateFileLinkDiff(filepath, link, result.fix)));
      }
      return result;
    })
  );
});
