{"version":3,"file":"default-DhvGO-Ho.js","sources":["../../../../../../../.nuxt/gql/default.ts"],"sourcesContent":["import type { GraphQLClient, RequestOptions } from 'graphql-request';\nimport { gql } from 'graphql-request';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = T | null;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\ntype GraphQLClientRequestHeaders = RequestOptions['requestHeaders'];\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: { input: string; output: string; }\n  String: { input: string; output: string; }\n  Boolean: { input: boolean; output: boolean; }\n  Int: { input: number; output: number; }\n  Float: { input: number; output: number; }\n};\n\n/** Input for the addCartItems mutation. */\nexport type AddCartItemsInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Cart items to be added */\n  items?: InputMaybe<Array<InputMaybe<CartItemInput>>>;\n};\n\n/** Input for the addFee mutation. */\nexport type AddFeeInput = {\n  /** Fee amount */\n  amount?: InputMaybe<Scalars['Float']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Unique name for the fee. */\n  name: Scalars['String']['input'];\n  /** The tax class for the fee if taxable. */\n  taxClass?: InputMaybe<TaxClassEnum>;\n  /** Is the fee taxable? */\n  taxable?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Input for the addMethodToShippingZone mutation. */\nexport type AddMethodToShippingZoneInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the shipping method is enabled or not. */\n  enabled?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the shipping method to add. */\n  methodId: Scalars['String']['input'];\n  /** The order of the shipping method. */\n  order?: InputMaybe<Scalars['Int']['input']>;\n  /** The settings for the shipping method. */\n  settings?: InputMaybe<Array<InputMaybe<WcSettingInput>>>;\n  /** The ID of the shipping zone to delete. */\n  zoneId: Scalars['Int']['input'];\n};\n\n/** Input for the addToCart mutation. */\nexport type AddToCartInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** JSON string representation of extra cart item data */\n  extraData?: InputMaybe<Scalars['String']['input']>;\n  /** Cart item product database ID or global ID */\n  productId: Scalars['Int']['input'];\n  /** Cart item quantity */\n  quantity?: InputMaybe<Scalars['Int']['input']>;\n  /** Cart item product variation attributes */\n  variation?: InputMaybe<Array<InputMaybe<ProductAttributeInput>>>;\n  /** Cart item product variation database ID or global ID */\n  variationId?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Input for the applyCoupon mutation. */\nexport type ApplyCouponInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Code of coupon being applied */\n  code: Scalars['String']['input'];\n};\n\n/** Collection statistic attributes operators */\nexport enum AttributeOperatorEnum {\n  AND = 'AND',\n  IN = 'IN',\n  NOT_IN = 'NOT_IN'\n}\n\n/** What rating to display avatars up to. Accepts 'G', 'PG', 'R', 'X', and are judged in that order. Default is the value of the 'avatar_rating' option */\nexport enum AvatarRatingEnum {\n  /** Indicates a G level avatar rating level. */\n  G = 'G',\n  /** Indicates a PG level avatar rating level. */\n  PG = 'PG',\n  /** Indicates an R level avatar rating level. */\n  R = 'R',\n  /** Indicates an X level avatar rating level. */\n  X = 'X'\n}\n\n/** Product backorder enumeration */\nexport enum BackordersEnum {\n  NO = 'NO',\n  NOTIFY = 'NOTIFY',\n  YES = 'YES'\n}\n\n/** Cart error type enumeration */\nexport enum CartErrorType {\n  INVALID_CART_ITEM = 'INVALID_CART_ITEM',\n  INVALID_COUPON = 'INVALID_COUPON',\n  INVALID_SHIPPING_METHOD = 'INVALID_SHIPPING_METHOD',\n  UNKNOWN = 'UNKNOWN'\n}\n\n/** Cart item quantity */\nexport type CartItemInput = {\n  /** JSON string representation of extra cart item data */\n  extraData?: InputMaybe<Scalars['String']['input']>;\n  /** Cart item product database ID or global ID */\n  productId: Scalars['Int']['input'];\n  /** Cart item quantity */\n  quantity?: InputMaybe<Scalars['Int']['input']>;\n  /** Cart item product variation attributes */\n  variation?: InputMaybe<Array<InputMaybe<ProductAttributeInput>>>;\n  /** Cart item product variation database ID or global ID */\n  variationId?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Cart item quantity */\nexport type CartItemQuantityInput = {\n  /** Cart item being updated */\n  key: Scalars['ID']['input'];\n  /** Cart item's new quantity */\n  quantity: Scalars['Int']['input'];\n};\n\n/** Arguments for filtering the CartItemToProductConnection connection */\nexport type CartItemToProductConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Arguments for filtering the CartToCartItemConnection connection */\nexport type CartToCartItemConnectionWhereArgs = {\n  /** Limit results to cart items that require shipping */\n  needsShipping?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Product catalog visibility enumeration */\nexport enum CatalogVisibilityEnum {\n  CATALOG = 'CATALOG',\n  HIDDEN = 'HIDDEN',\n  SEARCH = 'SEARCH',\n  VISIBLE = 'VISIBLE'\n}\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum CategoryIdType {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The name of the node */\n  NAME = 'NAME',\n  /** Url friendly name of the node */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI'\n}\n\n/** Arguments for filtering the CategoryToCategoryConnection connection */\nexport type CategoryToCategoryConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the CategoryToContentNodeConnection connection */\nexport type CategoryToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfCategoryEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the CategoryToPostConnection connection */\nexport type CategoryToPostConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Category ID */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Use Category Slug */\n  categoryName?: InputMaybe<Scalars['String']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Tag Slug */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Use Tag ID */\n  tagId?: InputMaybe<Scalars['String']['input']>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag slugs, used to display objects from one tag AND another */\n  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of tag slugs, used to include objects in ANY specified tags */\n  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the checkout mutation. */\nexport type CheckoutInput = {\n  /** Create new customer account */\n  account?: InputMaybe<CreateAccountInput>;\n  /** Order billing address */\n  billing?: InputMaybe<CustomerAddressInput>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Order customer note */\n  customerNote?: InputMaybe<Scalars['String']['input']>;\n  /** Define if the order is paid. It will set the status to processing and reduce stock items. */\n  isPaid?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Order meta data */\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n  /** Payment method ID. */\n  paymentMethod?: InputMaybe<Scalars['String']['input']>;\n  /** Ship to a separate address */\n  shipToDifferentAddress?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Order shipping address */\n  shipping?: InputMaybe<CustomerAddressInput>;\n  /** Order shipping method */\n  shippingMethod?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Order transaction ID */\n  transactionId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the clearShippingZoneLocations mutation. */\nexport type ClearShippingZoneLocationsInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The type of location to remove. */\n  type?: InputMaybe<ShippingLocationTypeEnum>;\n  /** The ID of the shipping zone to delete. */\n  zoneId: Scalars['Int']['input'];\n};\n\n/** Taxonomy query */\nexport type CollectionStatsQueryInput = {\n  /** Taxonomy relation to query */\n  relation?: InputMaybe<RelationEnum>;\n  /** Product Taxonomy */\n  taxonomy: ProductAttributeEnum;\n};\n\n/** Arguments used to filter the collection results */\nexport type CollectionStatsWhereArgs = {\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** The Type of Identifier used to fetch a single comment node. Default is \"ID\". To be used along with the \"id\" field. */\nexport enum CommentNodeIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID'\n}\n\n/** The status of the comment object. */\nexport enum CommentStatusEnum {\n  /** Comments with the Approved status */\n  APPROVE = 'APPROVE',\n  /** Comments with the Unapproved status */\n  HOLD = 'HOLD',\n  /** Comments with the Spam status */\n  SPAM = 'SPAM',\n  /** Comments with the Trash status */\n  TRASH = 'TRASH'\n}\n\n/** Arguments for filtering the CommentToCommentConnection connection */\nexport type CommentToCommentConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Arguments for filtering the CommentToParentCommentConnection connection */\nexport type CommentToParentCommentConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Options for ordering the connection */\nexport enum CommentsConnectionOrderbyEnum {\n  /** Order by browser user agent of the commenter. */\n  COMMENT_AGENT = 'COMMENT_AGENT',\n  /** Order by approval status of the comment. */\n  COMMENT_APPROVED = 'COMMENT_APPROVED',\n  /** Order by name of the comment author. */\n  COMMENT_AUTHOR = 'COMMENT_AUTHOR',\n  /** Order by e-mail of the comment author. */\n  COMMENT_AUTHOR_EMAIL = 'COMMENT_AUTHOR_EMAIL',\n  /** Order by IP address of the comment author. */\n  COMMENT_AUTHOR_IP = 'COMMENT_AUTHOR_IP',\n  /** Order by URL address of the comment author. */\n  COMMENT_AUTHOR_URL = 'COMMENT_AUTHOR_URL',\n  /** Order by the comment contents. */\n  COMMENT_CONTENT = 'COMMENT_CONTENT',\n  /** Order by date/time timestamp of the comment. */\n  COMMENT_DATE = 'COMMENT_DATE',\n  /** Order by GMT timezone date/time timestamp of the comment. */\n  COMMENT_DATE_GMT = 'COMMENT_DATE_GMT',\n  /** Order by the globally unique identifier for the comment object */\n  COMMENT_ID = 'COMMENT_ID',\n  /** Order by the array list of comment IDs listed in the where clause. */\n  COMMENT_IN = 'COMMENT_IN',\n  /** Order by the comment karma score. */\n  COMMENT_KARMA = 'COMMENT_KARMA',\n  /** Order by the comment parent ID. */\n  COMMENT_PARENT = 'COMMENT_PARENT',\n  /** Order by the post object ID. */\n  COMMENT_POST_ID = 'COMMENT_POST_ID',\n  /** Order by the the type of comment, such as 'comment', 'pingback', or 'trackback'. */\n  COMMENT_TYPE = 'COMMENT_TYPE',\n  /** Order by the user ID. */\n  USER_ID = 'USER_ID'\n}\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum ContentNodeIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID',\n  /** Identify a resource by the URI. */\n  URI = 'URI'\n}\n\n/** Allowed Content Types */\nexport enum ContentTypeEnum {\n  /** The Type of Content object */\n  ATTACHMENT = 'ATTACHMENT',\n  /** The Type of Content object */\n  PAGE = 'PAGE',\n  /** The Type of Content object */\n  POST = 'POST',\n  /** The Type of Content object */\n  PRODUCT = 'PRODUCT'\n}\n\n/** The Type of Identifier used to fetch a single Content Type node. To be used along with the \"id\" field. Default is \"ID\". */\nexport enum ContentTypeIdTypeEnum {\n  /** The globally unique ID */\n  ID = 'ID',\n  /** The name of the content type. */\n  NAME = 'NAME'\n}\n\n/** Arguments for filtering the ContentTypeToContentNodeConnection connection */\nexport type ContentTypeToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Allowed Content Types of the Category taxonomy. */\nexport enum ContentTypesOfCategoryEnum {\n  /** The Type of Content object */\n  POST = 'POST'\n}\n\n/** Allowed Content Types of the PostFormat taxonomy. */\nexport enum ContentTypesOfPostFormatEnum {\n  /** The Type of Content object */\n  POST = 'POST'\n}\n\n/** Allowed Content Types of the ProductCategory taxonomy. */\nexport enum ContentTypesOfProductCategoryEnum {\n  /** The Type of Content object */\n  PRODUCT = 'PRODUCT'\n}\n\n/** Allowed Content Types of the ProductTag taxonomy. */\nexport enum ContentTypesOfProductTagEnum {\n  /** The Type of Content object */\n  PRODUCT = 'PRODUCT'\n}\n\n/** Allowed Content Types of the ProductType taxonomy. */\nexport enum ContentTypesOfProductTypeEnum {\n  /** The Type of Content object */\n  PRODUCT = 'PRODUCT'\n}\n\n/** Allowed Content Types of the ShippingClass taxonomy. */\nexport enum ContentTypesOfShippingClassEnum {\n  /** The Type of Content object */\n  PRODUCT = 'PRODUCT'\n}\n\n/** Allowed Content Types of the Tag taxonomy. */\nexport enum ContentTypesOfTagEnum {\n  /** The Type of Content object */\n  POST = 'POST'\n}\n\n/** Allowed Content Types of the VisibleProduct taxonomy. */\nexport enum ContentTypesOfVisibleProductEnum {\n  /** The Type of Content object */\n  PRODUCT = 'PRODUCT'\n}\n\n/** Countries enumeration */\nexport enum CountriesEnum {\n  AD = 'AD',\n  AE = 'AE',\n  AF = 'AF',\n  AG = 'AG',\n  AI = 'AI',\n  AL = 'AL',\n  AM = 'AM',\n  AO = 'AO',\n  AQ = 'AQ',\n  AR = 'AR',\n  AS = 'AS',\n  AT = 'AT',\n  AU = 'AU',\n  AW = 'AW',\n  AX = 'AX',\n  AZ = 'AZ',\n  BA = 'BA',\n  BB = 'BB',\n  BD = 'BD',\n  BE = 'BE',\n  BF = 'BF',\n  BG = 'BG',\n  BH = 'BH',\n  BI = 'BI',\n  BJ = 'BJ',\n  BL = 'BL',\n  BM = 'BM',\n  BN = 'BN',\n  BO = 'BO',\n  BQ = 'BQ',\n  BR = 'BR',\n  BS = 'BS',\n  BT = 'BT',\n  BV = 'BV',\n  BW = 'BW',\n  BY = 'BY',\n  BZ = 'BZ',\n  CA = 'CA',\n  CC = 'CC',\n  CD = 'CD',\n  CF = 'CF',\n  CG = 'CG',\n  CH = 'CH',\n  CI = 'CI',\n  CK = 'CK',\n  CL = 'CL',\n  CM = 'CM',\n  CN = 'CN',\n  CO = 'CO',\n  CR = 'CR',\n  CU = 'CU',\n  CV = 'CV',\n  CW = 'CW',\n  CX = 'CX',\n  CY = 'CY',\n  CZ = 'CZ',\n  DE = 'DE',\n  DJ = 'DJ',\n  DK = 'DK',\n  DM = 'DM',\n  DO = 'DO',\n  DZ = 'DZ',\n  EC = 'EC',\n  EE = 'EE',\n  EG = 'EG',\n  EH = 'EH',\n  ER = 'ER',\n  ES = 'ES',\n  ET = 'ET',\n  FI = 'FI',\n  FJ = 'FJ',\n  FK = 'FK',\n  FM = 'FM',\n  FO = 'FO',\n  FR = 'FR',\n  GA = 'GA',\n  GB = 'GB',\n  GD = 'GD',\n  GE = 'GE',\n  GF = 'GF',\n  GG = 'GG',\n  GH = 'GH',\n  GI = 'GI',\n  GL = 'GL',\n  GM = 'GM',\n  GN = 'GN',\n  GP = 'GP',\n  GQ = 'GQ',\n  GR = 'GR',\n  GS = 'GS',\n  GT = 'GT',\n  GU = 'GU',\n  GW = 'GW',\n  GY = 'GY',\n  HK = 'HK',\n  HM = 'HM',\n  HN = 'HN',\n  HR = 'HR',\n  HT = 'HT',\n  HU = 'HU',\n  ID = 'ID',\n  IE = 'IE',\n  IL = 'IL',\n  IM = 'IM',\n  IN = 'IN',\n  IO = 'IO',\n  IQ = 'IQ',\n  IR = 'IR',\n  IS = 'IS',\n  IT = 'IT',\n  JE = 'JE',\n  JM = 'JM',\n  JO = 'JO',\n  JP = 'JP',\n  KE = 'KE',\n  KG = 'KG',\n  KH = 'KH',\n  KI = 'KI',\n  KM = 'KM',\n  KN = 'KN',\n  KP = 'KP',\n  KR = 'KR',\n  KW = 'KW',\n  KY = 'KY',\n  KZ = 'KZ',\n  LA = 'LA',\n  LB = 'LB',\n  LC = 'LC',\n  LI = 'LI',\n  LK = 'LK',\n  LR = 'LR',\n  LS = 'LS',\n  LT = 'LT',\n  LU = 'LU',\n  LV = 'LV',\n  LY = 'LY',\n  MA = 'MA',\n  MC = 'MC',\n  MD = 'MD',\n  ME = 'ME',\n  MF = 'MF',\n  MG = 'MG',\n  MH = 'MH',\n  MK = 'MK',\n  ML = 'ML',\n  MM = 'MM',\n  MN = 'MN',\n  MO = 'MO',\n  MP = 'MP',\n  MQ = 'MQ',\n  MR = 'MR',\n  MS = 'MS',\n  MT = 'MT',\n  MU = 'MU',\n  MV = 'MV',\n  MW = 'MW',\n  MX = 'MX',\n  MY = 'MY',\n  MZ = 'MZ',\n  NA = 'NA',\n  NC = 'NC',\n  NE = 'NE',\n  NF = 'NF',\n  NG = 'NG',\n  NI = 'NI',\n  NL = 'NL',\n  NO = 'NO',\n  NP = 'NP',\n  NR = 'NR',\n  NU = 'NU',\n  NZ = 'NZ',\n  OM = 'OM',\n  PA = 'PA',\n  PE = 'PE',\n  PF = 'PF',\n  PG = 'PG',\n  PH = 'PH',\n  PK = 'PK',\n  PL = 'PL',\n  PM = 'PM',\n  PN = 'PN',\n  PR = 'PR',\n  PS = 'PS',\n  PT = 'PT',\n  PW = 'PW',\n  PY = 'PY',\n  QA = 'QA',\n  RE = 'RE',\n  RO = 'RO',\n  RS = 'RS',\n  RU = 'RU',\n  RW = 'RW',\n  SA = 'SA',\n  SB = 'SB',\n  SC = 'SC',\n  SD = 'SD',\n  SE = 'SE',\n  SG = 'SG',\n  SH = 'SH',\n  SI = 'SI',\n  SJ = 'SJ',\n  SK = 'SK',\n  SL = 'SL',\n  SM = 'SM',\n  SN = 'SN',\n  SO = 'SO',\n  SR = 'SR',\n  SS = 'SS',\n  ST = 'ST',\n  SV = 'SV',\n  SX = 'SX',\n  SY = 'SY',\n  SZ = 'SZ',\n  TC = 'TC',\n  TD = 'TD',\n  TF = 'TF',\n  TG = 'TG',\n  TH = 'TH',\n  TJ = 'TJ',\n  TK = 'TK',\n  TL = 'TL',\n  TM = 'TM',\n  TN = 'TN',\n  TO = 'TO',\n  TR = 'TR',\n  TT = 'TT',\n  TV = 'TV',\n  TW = 'TW',\n  TZ = 'TZ',\n  UA = 'UA',\n  UG = 'UG',\n  UM = 'UM',\n  US = 'US',\n  UY = 'UY',\n  UZ = 'UZ',\n  VA = 'VA',\n  VC = 'VC',\n  VE = 'VE',\n  VG = 'VG',\n  VI = 'VI',\n  VN = 'VN',\n  VU = 'VU',\n  WF = 'WF',\n  WS = 'WS',\n  YE = 'YE',\n  YT = 'YT',\n  ZA = 'ZA',\n  ZM = 'ZM',\n  ZW = 'ZW'\n}\n\n/** The Type of Identifier used to fetch a single Coupon. Default is ID. */\nexport enum CouponIdTypeEnum {\n  /** Coupon code. */\n  CODE = 'CODE',\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID'\n}\n\n/** Arguments for filtering the CouponToCustomerConnection connection */\nexport type CouponToCustomerConnectionWhereArgs = {\n  /** Limit result set to resources with a specific email. */\n  email?: InputMaybe<Scalars['String']['input']>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Order of results. */\n  order?: InputMaybe<OrderEnum>;\n  /** Order results by a specific field. */\n  orderby?: InputMaybe<CustomerConnectionOrderbyEnum>;\n  /** Limit results to those matching a string. */\n  search?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the CouponToExcludedProductCategoriesConnection connection */\nexport type CouponToExcludedProductCategoriesConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the CouponToExcludedProductsConnection connection */\nexport type CouponToExcludedProductsConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Arguments for filtering the CouponToProductCategoryConnection connection */\nexport type CouponToProductCategoryConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the CouponToProductUnionConnection connection */\nexport type CouponToProductUnionConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Customer account credentials */\nexport type CreateAccountInput = {\n  /** Customer password */\n  password: Scalars['String']['input'];\n  /** Customer username */\n  username: Scalars['String']['input'];\n};\n\n/** Input for the createCategory mutation. */\nexport type CreateCategoryInput = {\n  /** The slug that the category will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the category object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the category object to mutate */\n  name: Scalars['String']['input'];\n  /** The ID of the category that should be set as the parent */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createComment mutation. */\nexport type CreateCommentInput = {\n  /** The approval status of the comment. */\n  approved?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the comment's author. */\n  author?: InputMaybe<Scalars['String']['input']>;\n  /** The email of the comment's author. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** The url of the comment's author. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The database ID of the post object the comment belongs to. */\n  commentOn?: InputMaybe<Scalars['Int']['input']>;\n  /** Content of the comment. */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** Parent comment ID of current comment. */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** The approval status of the comment */\n  status?: InputMaybe<CommentStatusEnum>;\n  /** Type of comment. */\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createCoupon mutation. */\nexport type CreateCouponInput = {\n  /** The amount of discount. Should always be numeric, even if setting a percentage. */\n  amount?: InputMaybe<Scalars['Float']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Coupon code. */\n  code: Scalars['String']['input'];\n  /** The date the coupon expires, in the site's timezone. */\n  dateExpires?: InputMaybe<Scalars['String']['input']>;\n  /** The date the coupon expires, as GMT. */\n  dateExpiresGmt?: InputMaybe<Scalars['String']['input']>;\n  /** Coupon description. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** Determines the type of discount that will be applied. */\n  discountType?: InputMaybe<DiscountTypeEnum>;\n  /** List of email addresses that can use this coupon. */\n  emailRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** If true, this coupon will not be applied to items that have sale prices. */\n  excludeSaleItems?: InputMaybe<Scalars['Boolean']['input']>;\n  /** List of category IDs the coupon does not apply to. */\n  excludedProductCategories?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** List of product IDs the coupon cannot be used on. */\n  excludedProductIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** If true and if the free shipping method requires a coupon, this coupon will enable free shipping. */\n  freeShipping?: InputMaybe<Scalars['Boolean']['input']>;\n  /** If true, the coupon can only be used individually. Other applied coupons will be removed from the cart. */\n  individualUse?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Max number of items in the cart the coupon can be applied to. */\n  limitUsageToXItems?: InputMaybe<Scalars['Int']['input']>;\n  /** Maximum order amount allowed when using the coupon. */\n  maximumAmount?: InputMaybe<Scalars['String']['input']>;\n  /** Meta data. */\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n  /** Minimum order amount that needs to be in the cart before coupon applies. */\n  minimumAmount?: InputMaybe<Scalars['String']['input']>;\n  /** List of category IDs the coupon applies to. */\n  productCategories?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** List of product IDs the coupon can be used on. */\n  productIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** How many times the coupon can be used in total. */\n  usageLimit?: InputMaybe<Scalars['Int']['input']>;\n  /** How many times the coupon can be used per customer. */\n  usageLimitPerUser?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Input for the createMediaItem mutation. */\nexport type CreateMediaItemInput = {\n  /** Alternative text to display when mediaItem is not displayed */\n  altText?: InputMaybe<Scalars['String']['input']>;\n  /** The userId to assign as the author of the mediaItem */\n  authorId?: InputMaybe<Scalars['ID']['input']>;\n  /** The caption for the mediaItem */\n  caption?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The comment status for the mediaItem */\n  commentStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the mediaItem */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** The date (in GMT zone) of the mediaItem */\n  dateGmt?: InputMaybe<Scalars['String']['input']>;\n  /** Description of the mediaItem */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The file name of the mediaItem */\n  filePath?: InputMaybe<Scalars['String']['input']>;\n  /** The file type of the mediaItem */\n  fileType?: InputMaybe<MimeTypeEnum>;\n  /** The ID of the parent object */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n  /** The ping status for the mediaItem */\n  pingStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the mediaItem */\n  slug?: InputMaybe<Scalars['String']['input']>;\n  /** The status of the mediaItem */\n  status?: InputMaybe<MediaItemStatusEnum>;\n  /** The title of the mediaItem */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createOrder mutation. */\nexport type CreateOrderInput = {\n  /** Order billing address */\n  billing?: InputMaybe<CustomerAddressInput>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Coupons codes to be applied to order */\n  coupons?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Currency the order was created with, in ISO format. */\n  currency?: InputMaybe<CurrencyEnum>;\n  /** Order customer ID */\n  customerId?: InputMaybe<Scalars['Int']['input']>;\n  /** Note left by customer during checkout. */\n  customerNote?: InputMaybe<Scalars['String']['input']>;\n  /** Order shipping lines */\n  feeLines?: InputMaybe<Array<InputMaybe<FeeLineInput>>>;\n  /** Define if the order is paid. It will set the status to processing and reduce stock items. */\n  isPaid?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Order line items */\n  lineItems?: InputMaybe<Array<InputMaybe<LineItemInput>>>;\n  /** Order meta data */\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n  /** Parent order ID. */\n  parentId?: InputMaybe<Scalars['Int']['input']>;\n  /** Payment method ID. */\n  paymentMethod?: InputMaybe<Scalars['String']['input']>;\n  /** Payment method title. */\n  paymentMethodTitle?: InputMaybe<Scalars['String']['input']>;\n  /** Order shipping address */\n  shipping?: InputMaybe<CustomerAddressInput>;\n  /** Order shipping lines */\n  shippingLines?: InputMaybe<Array<InputMaybe<ShippingLineInput>>>;\n  /** Order status */\n  status?: InputMaybe<OrderStatusEnum>;\n  /** Order transaction ID */\n  transactionId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createPage mutation. */\nexport type CreatePageInput = {\n  /** The userId to assign as the author of the object */\n  authorId?: InputMaybe<Scalars['ID']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The comment status for the object */\n  commentStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The content of the object */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */\n  menuOrder?: InputMaybe<Scalars['Int']['input']>;\n  /** The ID of the parent object */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n  /** The password used to protect the content of the object */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the object */\n  slug?: InputMaybe<Scalars['String']['input']>;\n  /** The status of the object */\n  status?: InputMaybe<PostStatusEnum>;\n  /** The title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createPostFormat mutation. */\nexport type CreatePostFormatInput = {\n  /** The slug that the post_format will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the post_format object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the post_format object to mutate */\n  name: Scalars['String']['input'];\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createPost mutation. */\nexport type CreatePostInput = {\n  /** The userId to assign as the author of the object */\n  authorId?: InputMaybe<Scalars['ID']['input']>;\n  /** Set connections between the post and categories */\n  categories?: InputMaybe<PostCategoriesInput>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The comment status for the object */\n  commentStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The content of the object */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** The excerpt of the object */\n  excerpt?: InputMaybe<Scalars['String']['input']>;\n  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */\n  menuOrder?: InputMaybe<Scalars['Int']['input']>;\n  /** The password used to protect the content of the object */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** The ping status for the object */\n  pingStatus?: InputMaybe<Scalars['String']['input']>;\n  /** URLs that have been pinged. */\n  pinged?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Set connections between the post and postFormats */\n  postFormats?: InputMaybe<PostPostFormatsInput>;\n  /** The slug of the object */\n  slug?: InputMaybe<Scalars['String']['input']>;\n  /** The status of the object */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Set connections between the post and tags */\n  tags?: InputMaybe<PostTagsInput>;\n  /** The title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n  /** URLs queued to be pinged. */\n  toPing?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Input for the createProductCategory mutation. */\nexport type CreateProductCategoryInput = {\n  /** The slug that the product_cat will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_cat object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the product_cat object to mutate */\n  name: Scalars['String']['input'];\n  /** The ID of the product_cat that should be set as the parent */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createProduct mutation. */\nexport type CreateProductInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The comment status for the object */\n  commentStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The content of the object */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** The excerpt of the object */\n  excerpt?: InputMaybe<Scalars['String']['input']>;\n  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */\n  menuOrder?: InputMaybe<Scalars['Int']['input']>;\n  /** The password used to protect the content of the object */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Set connections between the Product and productCategories */\n  productCategories?: InputMaybe<ProductProductCategoriesInput>;\n  /** Set connections between the Product and productTags */\n  productTags?: InputMaybe<ProductProductTagsInput>;\n  /** Set connections between the Product and productTypes */\n  productTypes?: InputMaybe<ProductProductTypesInput>;\n  /** Set connections between the Product and shippingClasses */\n  shippingClasses?: InputMaybe<ProductShippingClassesInput>;\n  /** The slug of the object */\n  slug?: InputMaybe<Scalars['String']['input']>;\n  /** The status of the object */\n  status?: InputMaybe<PostStatusEnum>;\n  /** The title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n  /** Set connections between the Product and visibleProducts */\n  visibleProducts?: InputMaybe<ProductVisibleProductsInput>;\n};\n\n/** Input for the createProductTag mutation. */\nexport type CreateProductTagInput = {\n  /** The slug that the product_tag will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_tag object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the product_tag object to mutate */\n  name: Scalars['String']['input'];\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createProductType mutation. */\nexport type CreateProductTypeInput = {\n  /** The slug that the product_type will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_type object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the product_type object to mutate */\n  name: Scalars['String']['input'];\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createShippingClass mutation. */\nexport type CreateShippingClassInput = {\n  /** The slug that the product_shipping_class will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_shipping_class object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the product_shipping_class object to mutate */\n  name: Scalars['String']['input'];\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createShippingZone mutation. */\nexport type CreateShippingZoneInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Name of the shipping zone. */\n  name: Scalars['String']['input'];\n  /** Order of the shipping zone. */\n  order?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Input for the createTag mutation. */\nexport type CreateTagInput = {\n  /** The slug that the post_tag will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the post_tag object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the post_tag object to mutate */\n  name: Scalars['String']['input'];\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createTaxClass mutation. */\nexport type CreateTaxClassInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Name of the tax class. */\n  name: Scalars['String']['input'];\n  /** Slug of the tax class. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createTaxRate mutation. */\nexport type CreateTaxRateInput = {\n  /** Cities for the tax rate. */\n  cities?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Tax rate class. */\n  class?: InputMaybe<TaxClassEnum>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the tax rate is compound. */\n  compound?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Country code for the tax rate. */\n  country?: InputMaybe<Scalars['String']['input']>;\n  /** Tax rate name. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Tax rate order. */\n  order?: InputMaybe<Scalars['Int']['input']>;\n  /** Postcodes for the tax rate. */\n  postcodes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Tax rate priority. */\n  priority?: InputMaybe<Scalars['Int']['input']>;\n  /** Tax rate. */\n  rate?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the tax rate is applied to shipping. */\n  shipping?: InputMaybe<Scalars['Boolean']['input']>;\n  /** State code for the tax rate. */\n  state?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createUser mutation. */\nexport type CreateUserInput = {\n  /** User's AOL IM account. */\n  aim?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing content about the user. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user). */\n  displayName?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing the user's email address. */\n  email?: InputMaybe<Scalars['String']['input']>;\n  /** \tThe user's first name. */\n  firstName?: InputMaybe<Scalars['String']['input']>;\n  /** User's Jabber account. */\n  jabber?: InputMaybe<Scalars['String']['input']>;\n  /** The user's last name. */\n  lastName?: InputMaybe<Scalars['String']['input']>;\n  /** User's locale. */\n  locale?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains a URL-friendly name for the user. The default is the user's username. */\n  nicename?: InputMaybe<Scalars['String']['input']>;\n  /** The user's nickname, defaults to the user's username. */\n  nickname?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains the plain text password for the user. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** The date the user registered. Format is Y-m-d H:i:s. */\n  registered?: InputMaybe<Scalars['String']['input']>;\n  /** A string for whether to enable the rich editor or not. False if not empty. */\n  richEditing?: InputMaybe<Scalars['String']['input']>;\n  /** An array of roles to be assigned to the user. */\n  roles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** A string that contains the user's username for logging in. */\n  username: Scalars['String']['input'];\n  /** A string containing the user's URL for the user's web site. */\n  websiteUrl?: InputMaybe<Scalars['String']['input']>;\n  /** User's Yahoo IM account. */\n  yim?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the createVisibleProduct mutation. */\nexport type CreateVisibleProductInput = {\n  /** The slug that the product_visibility will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_visibility object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the product_visibility object to mutate */\n  name: Scalars['String']['input'];\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Currencies enumeration */\nexport enum CurrencyEnum {\n  /** United Arab Emirates dirham */\n  AED = 'AED',\n  /** Afghan afghani */\n  AFN = 'AFN',\n  /** Albanian lek */\n  ALL = 'ALL',\n  /** Armenian dram */\n  AMD = 'AMD',\n  /** Netherlands Antillean guilder */\n  ANG = 'ANG',\n  /** Angolan kwanza */\n  AOA = 'AOA',\n  /** Argentine peso */\n  ARS = 'ARS',\n  /** Australian dollar */\n  AUD = 'AUD',\n  /** Aruban florin */\n  AWG = 'AWG',\n  /** Azerbaijani manat */\n  AZN = 'AZN',\n  /** Bosnia and Herzegovina convertible mark */\n  BAM = 'BAM',\n  /** Barbadian dollar */\n  BBD = 'BBD',\n  /** Bangladeshi taka */\n  BDT = 'BDT',\n  /** Bulgarian lev */\n  BGN = 'BGN',\n  /** Bahraini dinar */\n  BHD = 'BHD',\n  /** Burundian franc */\n  BIF = 'BIF',\n  /** Bermudian dollar */\n  BMD = 'BMD',\n  /** Brunei dollar */\n  BND = 'BND',\n  /** Bolivian boliviano */\n  BOB = 'BOB',\n  /** Brazilian real */\n  BRL = 'BRL',\n  /** Bahamian dollar */\n  BSD = 'BSD',\n  /** Bitcoin */\n  BTC = 'BTC',\n  /** Bhutanese ngultrum */\n  BTN = 'BTN',\n  /** Botswana pula */\n  BWP = 'BWP',\n  /** Belarusian ruble */\n  BYN = 'BYN',\n  /** Belarusian ruble (old) */\n  BYR = 'BYR',\n  /** Belize dollar */\n  BZD = 'BZD',\n  /** Canadian dollar */\n  CAD = 'CAD',\n  /** Congolese franc */\n  CDF = 'CDF',\n  /** Swiss franc */\n  CHF = 'CHF',\n  /** Chilean peso */\n  CLP = 'CLP',\n  /** Chinese yuan */\n  CNY = 'CNY',\n  /** Colombian peso */\n  COP = 'COP',\n  /** Costa Rican col&oacute;n */\n  CRC = 'CRC',\n  /** Cuban convertible peso */\n  CUC = 'CUC',\n  /** Cuban peso */\n  CUP = 'CUP',\n  /** Cape Verdean escudo */\n  CVE = 'CVE',\n  /** Czech koruna */\n  CZK = 'CZK',\n  /** Djiboutian franc */\n  DJF = 'DJF',\n  /** Danish krone */\n  DKK = 'DKK',\n  /** Dominican peso */\n  DOP = 'DOP',\n  /** Algerian dinar */\n  DZD = 'DZD',\n  /** Egyptian pound */\n  EGP = 'EGP',\n  /** Eritrean nakfa */\n  ERN = 'ERN',\n  /** Ethiopian birr */\n  ETB = 'ETB',\n  /** Euro */\n  EUR = 'EUR',\n  /** Fijian dollar */\n  FJD = 'FJD',\n  /** Falkland Islands pound */\n  FKP = 'FKP',\n  /** Pound sterling */\n  GBP = 'GBP',\n  /** Georgian lari */\n  GEL = 'GEL',\n  /** Guernsey pound */\n  GGP = 'GGP',\n  /** Ghana cedi */\n  GHS = 'GHS',\n  /** Gibraltar pound */\n  GIP = 'GIP',\n  /** Gambian dalasi */\n  GMD = 'GMD',\n  /** Guinean franc */\n  GNF = 'GNF',\n  /** Guatemalan quetzal */\n  GTQ = 'GTQ',\n  /** Guyanese dollar */\n  GYD = 'GYD',\n  /** Hong Kong dollar */\n  HKD = 'HKD',\n  /** Honduran lempira */\n  HNL = 'HNL',\n  /** Croatian kuna */\n  HRK = 'HRK',\n  /** Haitian gourde */\n  HTG = 'HTG',\n  /** Hungarian forint */\n  HUF = 'HUF',\n  /** Indonesian rupiah */\n  IDR = 'IDR',\n  /** Israeli new shekel */\n  ILS = 'ILS',\n  /** Manx pound */\n  IMP = 'IMP',\n  /** Indian rupee */\n  INR = 'INR',\n  /** Iraqi dinar */\n  IQD = 'IQD',\n  /** Iranian rial */\n  IRR = 'IRR',\n  /** Iranian toman */\n  IRT = 'IRT',\n  /** Icelandic kr&oacute;na */\n  ISK = 'ISK',\n  /** Jersey pound */\n  JEP = 'JEP',\n  /** Jamaican dollar */\n  JMD = 'JMD',\n  /** Jordanian dinar */\n  JOD = 'JOD',\n  /** Japanese yen */\n  JPY = 'JPY',\n  /** Kenyan shilling */\n  KES = 'KES',\n  /** Kyrgyzstani som */\n  KGS = 'KGS',\n  /** Cambodian riel */\n  KHR = 'KHR',\n  /** Comorian franc */\n  KMF = 'KMF',\n  /** North Korean won */\n  KPW = 'KPW',\n  /** South Korean won */\n  KRW = 'KRW',\n  /** Kuwaiti dinar */\n  KWD = 'KWD',\n  /** Cayman Islands dollar */\n  KYD = 'KYD',\n  /** Kazakhstani tenge */\n  KZT = 'KZT',\n  /** Lao kip */\n  LAK = 'LAK',\n  /** Lebanese pound */\n  LBP = 'LBP',\n  /** Sri Lankan rupee */\n  LKR = 'LKR',\n  /** Liberian dollar */\n  LRD = 'LRD',\n  /** Lesotho loti */\n  LSL = 'LSL',\n  /** Libyan dinar */\n  LYD = 'LYD',\n  /** Moroccan dirham */\n  MAD = 'MAD',\n  /** Moldovan leu */\n  MDL = 'MDL',\n  /** Malagasy ariary */\n  MGA = 'MGA',\n  /** Macedonian denar */\n  MKD = 'MKD',\n  /** Burmese kyat */\n  MMK = 'MMK',\n  /** Mongolian t&ouml;gr&ouml;g */\n  MNT = 'MNT',\n  /** Macanese pataca */\n  MOP = 'MOP',\n  /** Mauritanian ouguiya */\n  MRU = 'MRU',\n  /** Mauritian rupee */\n  MUR = 'MUR',\n  /** Maldivian rufiyaa */\n  MVR = 'MVR',\n  /** Malawian kwacha */\n  MWK = 'MWK',\n  /** Mexican peso */\n  MXN = 'MXN',\n  /** Malaysian ringgit */\n  MYR = 'MYR',\n  /** Mozambican metical */\n  MZN = 'MZN',\n  /** Namibian dollar */\n  NAD = 'NAD',\n  /** Nigerian naira */\n  NGN = 'NGN',\n  /** Nicaraguan c&oacute;rdoba */\n  NIO = 'NIO',\n  /** Norwegian krone */\n  NOK = 'NOK',\n  /** Nepalese rupee */\n  NPR = 'NPR',\n  /** New Zealand dollar */\n  NZD = 'NZD',\n  /** Omani rial */\n  OMR = 'OMR',\n  /** Panamanian balboa */\n  PAB = 'PAB',\n  /** Sol */\n  PEN = 'PEN',\n  /** Papua New Guinean kina */\n  PGK = 'PGK',\n  /** Philippine peso */\n  PHP = 'PHP',\n  /** Pakistani rupee */\n  PKR = 'PKR',\n  /** Polish z&#x142;oty */\n  PLN = 'PLN',\n  /** Transnistrian ruble */\n  PRB = 'PRB',\n  /** Paraguayan guaran&iacute; */\n  PYG = 'PYG',\n  /** Qatari riyal */\n  QAR = 'QAR',\n  /** Romanian leu */\n  RON = 'RON',\n  /** Serbian dinar */\n  RSD = 'RSD',\n  /** Russian ruble */\n  RUB = 'RUB',\n  /** Rwandan franc */\n  RWF = 'RWF',\n  /** Saudi riyal */\n  SAR = 'SAR',\n  /** Solomon Islands dollar */\n  SBD = 'SBD',\n  /** Seychellois rupee */\n  SCR = 'SCR',\n  /** Sudanese pound */\n  SDG = 'SDG',\n  /** Swedish krona */\n  SEK = 'SEK',\n  /** Singapore dollar */\n  SGD = 'SGD',\n  /** Saint Helena pound */\n  SHP = 'SHP',\n  /** Sierra Leonean leone */\n  SLL = 'SLL',\n  /** Somali shilling */\n  SOS = 'SOS',\n  /** Surinamese dollar */\n  SRD = 'SRD',\n  /** South Sudanese pound */\n  SSP = 'SSP',\n  /** S&atilde;o Tom&eacute; and Pr&iacute;ncipe dobra */\n  STN = 'STN',\n  /** Syrian pound */\n  SYP = 'SYP',\n  /** Swazi lilangeni */\n  SZL = 'SZL',\n  /** Thai baht */\n  THB = 'THB',\n  /** Tajikistani somoni */\n  TJS = 'TJS',\n  /** Turkmenistan manat */\n  TMT = 'TMT',\n  /** Tunisian dinar */\n  TND = 'TND',\n  /** Tongan pa&#x2bb;anga */\n  TOP = 'TOP',\n  /** Turkish lira */\n  TRY = 'TRY',\n  /** Trinidad and Tobago dollar */\n  TTD = 'TTD',\n  /** New Taiwan dollar */\n  TWD = 'TWD',\n  /** Tanzanian shilling */\n  TZS = 'TZS',\n  /** Ukrainian hryvnia */\n  UAH = 'UAH',\n  /** Ugandan shilling */\n  UGX = 'UGX',\n  /** United States (US) dollar */\n  USD = 'USD',\n  /** Uruguayan peso */\n  UYU = 'UYU',\n  /** Uzbekistani som */\n  UZS = 'UZS',\n  /** Venezuelan bol&iacute;var (20082018) */\n  VEF = 'VEF',\n  /** Venezuelan bol&iacute;var */\n  VES = 'VES',\n  /** Vietnamese &#x111;&#x1ed3;ng */\n  VND = 'VND',\n  /** Vanuatu vatu */\n  VUV = 'VUV',\n  /** Samoan t&#x101;l&#x101; */\n  WST = 'WST',\n  /** Central African CFA franc */\n  XAF = 'XAF',\n  /** East Caribbean dollar */\n  XCD = 'XCD',\n  /** West African CFA franc */\n  XOF = 'XOF',\n  /** CFP franc */\n  XPF = 'XPF',\n  /** Yemeni rial */\n  YER = 'YER',\n  /** South African rand */\n  ZAR = 'ZAR',\n  /** Zambian kwacha */\n  ZMW = 'ZMW'\n}\n\n/** Customer address information */\nexport type CustomerAddressInput = {\n  /** Address 1 */\n  address1?: InputMaybe<Scalars['String']['input']>;\n  /** Address 2 */\n  address2?: InputMaybe<Scalars['String']['input']>;\n  /** City */\n  city?: InputMaybe<Scalars['String']['input']>;\n  /** Company */\n  company?: InputMaybe<Scalars['String']['input']>;\n  /** Country */\n  country?: InputMaybe<CountriesEnum>;\n  /** E-mail */\n  email?: InputMaybe<Scalars['String']['input']>;\n  /** First name */\n  firstName?: InputMaybe<Scalars['String']['input']>;\n  /** Last name */\n  lastName?: InputMaybe<Scalars['String']['input']>;\n  /** Clear old address data */\n  overwrite?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Phone */\n  phone?: InputMaybe<Scalars['String']['input']>;\n  /** Zip Postal Code */\n  postcode?: InputMaybe<Scalars['String']['input']>;\n  /** State */\n  state?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Field to order the connection by */\nexport enum CustomerConnectionOrderbyEnum {\n  /** Order by customer email */\n  EMAIL = 'EMAIL',\n  /** Order by customer ID */\n  ID = 'ID',\n  /** Order by include field */\n  INCLUDE = 'INCLUDE',\n  /** Order by customer display name */\n  NAME = 'NAME',\n  /** Order by customer registration date */\n  REGISTERED_DATE = 'REGISTERED_DATE',\n  /** Order by customer username */\n  USERNAME = 'USERNAME'\n}\n\n/** Arguments for filtering the CustomerToDownloadableItemConnection connection */\nexport type CustomerToDownloadableItemConnectionWhereArgs = {\n  /** Limit results to downloadable items that can be downloaded now. */\n  active?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit results to downloadable items that are expired. */\n  expired?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit results to downloadable items that have downloads remaining. */\n  hasDownloadsRemaining?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the CustomerToOrderConnection connection */\nexport type CustomerToOrderConnectionWhereArgs = {\n  /** Limit result set to orders assigned a specific billing email. */\n  billingEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to orders assigned a specific customer. */\n  customerId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to orders assigned a specific group of customers. */\n  customersIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<OrdersOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to orders assigned a specific product. */\n  productId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit results to those matching a string. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to orders assigned a specific status. */\n  statuses?: InputMaybe<Array<InputMaybe<OrderStatusEnum>>>;\n};\n\n/** Arguments for filtering the CustomerToRefundConnection connection */\nexport type CustomerToRefundConnectionWhereArgs = {\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to refunds from a specific group of order IDs. */\n  orderIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostTypeOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit results to those matching a string. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to refunds assigned a specific status. */\n  statuses?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Date values */\nexport type DateInput = {\n  /** Day of the month (from 1 to 31) */\n  day?: InputMaybe<Scalars['Int']['input']>;\n  /** Month number (from 1 to 12) */\n  month?: InputMaybe<Scalars['Int']['input']>;\n  /** 4 digit year (e.g. 2017) */\n  year?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Filter the connection based on input */\nexport type DateQueryInput = {\n  /** Nodes should be returned after this date */\n  after?: InputMaybe<DateInput>;\n  /** Nodes should be returned before this date */\n  before?: InputMaybe<DateInput>;\n  /** Column to query against */\n  column?: InputMaybe<PostObjectsConnectionDateColumnEnum>;\n  /** For after/before, whether exact value should be matched or not */\n  compare?: InputMaybe<Scalars['String']['input']>;\n  /** Day of the month (from 1 to 31) */\n  day?: InputMaybe<Scalars['Int']['input']>;\n  /** Hour (from 0 to 23) */\n  hour?: InputMaybe<Scalars['Int']['input']>;\n  /** For after/before, whether exact value should be matched or not */\n  inclusive?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Minute (from 0 to 59) */\n  minute?: InputMaybe<Scalars['Int']['input']>;\n  /** Month number (from 1 to 12) */\n  month?: InputMaybe<Scalars['Int']['input']>;\n  /** OR or AND, how the sub-arrays should be compared */\n  relation?: InputMaybe<RelationEnum>;\n  /** Second (0 to 59) */\n  second?: InputMaybe<Scalars['Int']['input']>;\n  /** Week of the year (from 0 to 53) */\n  week?: InputMaybe<Scalars['Int']['input']>;\n  /** 4 digit year (e.g. 2017) */\n  year?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Input for the deleteCategory mutation. */\nexport type DeleteCategoryInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the category to delete */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteComment mutation. */\nexport type DeleteCommentInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the comment should be force deleted instead of being moved to the trash */\n  forceDelete?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The deleted comment ID */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteCoupon mutation. */\nexport type DeleteCouponInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Delete the object. Set to \"false\" by default. */\n  forceDelete?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Unique identifier for the object. */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteMediaItem mutation. */\nexport type DeleteMediaItemInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the mediaItem should be force deleted instead of being moved to the trash */\n  forceDelete?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the mediaItem to delete */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteOrder mutation. */\nexport type DeleteOrderInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Delete or simply place in trash. */\n  forceDelete?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Order global ID */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** Order WP ID */\n  orderId?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Input for the deleteOrderItems mutation. */\nexport type DeleteOrderItemsInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Order global ID */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** ID Order items being deleted */\n  itemIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Order WP ID */\n  orderId?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Input for the deletePage mutation. */\nexport type DeletePageInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the object should be force deleted instead of being moved to the trash */\n  forceDelete?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the page to delete */\n  id: Scalars['ID']['input'];\n  /** Override the edit lock when another user is editing the post */\n  ignoreEditLock?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Input for the deletePaymentMethod mutation. */\nexport type DeletePaymentMethodInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Token ID of the payment token being deleted. */\n  tokenId: Scalars['Int']['input'];\n};\n\n/** Input for the deletePostFormat mutation. */\nexport type DeletePostFormatInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the postFormat to delete */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deletePost mutation. */\nexport type DeletePostInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the object should be force deleted instead of being moved to the trash */\n  forceDelete?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the post to delete */\n  id: Scalars['ID']['input'];\n  /** Override the edit lock when another user is editing the post */\n  ignoreEditLock?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Input for the deleteProductCategory mutation. */\nexport type DeleteProductCategoryInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the productCategory to delete */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteProduct mutation. */\nexport type DeleteProductInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the object should be force deleted instead of being moved to the trash */\n  forceDelete?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the Product to delete */\n  id: Scalars['ID']['input'];\n  /** Override the edit lock when another user is editing the post */\n  ignoreEditLock?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Input for the deleteProductTag mutation. */\nexport type DeleteProductTagInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the productTag to delete */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteProductType mutation. */\nexport type DeleteProductTypeInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the productType to delete */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteReview mutation. */\nexport type DeleteReviewInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the product review should be force deleted instead of being moved to the trash */\n  forceDelete?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The ID of the target product review */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteShippingClass mutation. */\nexport type DeleteShippingClassInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the shippingClass to delete */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteShippingZone mutation. */\nexport type DeleteShippingZoneInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the shipping zone to delete. */\n  id: Scalars['Int']['input'];\n};\n\n/** Input for the deleteTag mutation. */\nexport type DeleteTagInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the tag to delete */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the deleteTaxClass mutation. */\nexport type DeleteTaxClassInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Slug of the tax class. */\n  slug: Scalars['String']['input'];\n};\n\n/** Input for the deleteTaxRate mutation. */\nexport type DeleteTaxRateInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the tax rate to update. */\n  id: Scalars['Int']['input'];\n};\n\n/** Input for the deleteUser mutation. */\nexport type DeleteUserInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the user you want to delete */\n  id: Scalars['ID']['input'];\n  /** Reassign posts and links to new User ID. */\n  reassignId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Input for the deleteVisibleProduct mutation. */\nexport type DeleteVisibleProductInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the visibleProduct to delete */\n  id: Scalars['ID']['input'];\n};\n\n/** Coupon discount type enumeration */\nexport enum DiscountTypeEnum {\n  /** Fixed cart discount */\n  FIXED_CART = 'FIXED_CART',\n  /** Fixed product discount */\n  FIXED_PRODUCT = 'FIXED_PRODUCT',\n  /** Percentage discount */\n  PERCENT = 'PERCENT'\n}\n\n/** Input for the emptyCart mutation. */\nexport type EmptyCartInput = {\n  clearPersistentCart?: InputMaybe<Scalars['Boolean']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Fee line data. */\nexport type FeeLineInput = {\n  /** Fee amount. */\n  amount?: InputMaybe<Scalars['String']['input']>;\n  /** Fee Line ID */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** Fee name. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Tax class of fee. */\n  taxClass?: InputMaybe<TaxClassEnum>;\n  /** Tax status of fee. */\n  taxStatus?: InputMaybe<TaxStatusEnum>;\n  /** Line total (after discounts). */\n  total?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the fillCart mutation. */\nexport type FillCartInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Coupons to be applied to the cart */\n  coupons?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Cart items to be added */\n  items?: InputMaybe<Array<InputMaybe<CartItemInput>>>;\n  /** Shipping methods to be used. */\n  shippingMethods?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Input for the forgetSession mutation. */\nexport type ForgetSessionInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the GlobalProductAttributeToTermNodeConnection connection */\nexport type GlobalProductAttributeToTermNodeConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<ProductAttributesConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the GroupProductToProductUnionConnection connection */\nexport type GroupProductToProductUnionConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Arguments for filtering the HierarchicalContentNodeToContentNodeAncestorsConnection connection */\nexport type HierarchicalContentNodeToContentNodeAncestorsConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the HierarchicalContentNodeToContentNodeChildrenConnection connection */\nexport type HierarchicalContentNodeToContentNodeChildrenConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Meta data. */\nexport type LineItemInput = {\n  /** Line Item ID */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** Meta data. */\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n  /** Line name */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Product ID. */\n  productId?: InputMaybe<Scalars['Int']['input']>;\n  /** Quantity ordered. */\n  quantity?: InputMaybe<Scalars['Int']['input']>;\n  /** Product SKU. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Line subtotal (before discounts). */\n  subtotal?: InputMaybe<Scalars['String']['input']>;\n  /** Tax class of product. */\n  taxClass?: InputMaybe<TaxClassEnum>;\n  /** Line total (after discounts). */\n  total?: InputMaybe<Scalars['String']['input']>;\n  /** Variation ID, if applicable. */\n  variationId?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Arguments for filtering the LineItemToProductConnection connection */\nexport type LineItemToProductConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Input for the loginWithCookies mutation. */\nexport type LoginWithCookiesInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Input your user/e-mail. */\n  login: Scalars['String']['input'];\n  /** Input your password. */\n  password: Scalars['String']['input'];\n  /** Whether to \"remember\" the user. Increases the time that the cookie will be kept. Default false. */\n  rememberMe?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Input for the logout mutation. */\nexport type LogoutInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Product manage stock enumeration */\nexport enum ManageStockEnum {\n  FALSE = 'FALSE',\n  PARENT = 'PARENT',\n  TRUE = 'TRUE'\n}\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum MediaItemIdType {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID',\n  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */\n  SLUG = 'SLUG',\n  /** Identify a media item by its source url */\n  SOURCE_URL = 'SOURCE_URL',\n  /** Identify a resource by the URI. */\n  URI = 'URI'\n}\n\n/** The size of the media item object. */\nexport enum MediaItemSizeEnum {\n  /** MediaItem with the large size */\n  LARGE = 'LARGE',\n  /** MediaItem with the medium size */\n  MEDIUM = 'MEDIUM',\n  /** MediaItem with the medium_large size */\n  MEDIUM_LARGE = 'MEDIUM_LARGE',\n  /** MediaItem with the thumbnail size */\n  THUMBNAIL = 'THUMBNAIL',\n  /** MediaItem with the woocommerce_gallery_thumbnail size */\n  WOOCOMMERCE_GALLERY_THUMBNAIL = 'WOOCOMMERCE_GALLERY_THUMBNAIL',\n  /** MediaItem with the woocommerce_single size */\n  WOOCOMMERCE_SINGLE = 'WOOCOMMERCE_SINGLE',\n  /** MediaItem with the woocommerce_thumbnail size */\n  WOOCOMMERCE_THUMBNAIL = 'WOOCOMMERCE_THUMBNAIL',\n  /** MediaItem with the 1536x1536 size */\n  _1536X1536 = '_1536X1536',\n  /** MediaItem with the 2048x2048 size */\n  _2048X2048 = '_2048X2048'\n}\n\n/** The status of the media item object. */\nexport enum MediaItemStatusEnum {\n  /** Objects with the auto-draft status */\n  AUTO_DRAFT = 'AUTO_DRAFT',\n  /** Objects with the inherit status */\n  INHERIT = 'INHERIT',\n  /** Objects with the private status */\n  PRIVATE = 'PRIVATE',\n  /** Objects with the trash status */\n  TRASH = 'TRASH'\n}\n\n/** Arguments for filtering the MediaItemToCommentConnection connection */\nexport type MediaItemToCommentConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** The Type of Identifier used to fetch a single node. Default is \"ID\". To be used along with the \"id\" field. */\nexport enum MenuItemNodeIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID'\n}\n\n/** Arguments for filtering the MenuItemToMenuItemConnection connection */\nexport type MenuItemToMenuItemConnectionWhereArgs = {\n  /** The database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** The menu location for the menu being queried */\n  location?: InputMaybe<MenuLocationEnum>;\n  /** The database ID of the parent menu object */\n  parentDatabaseId?: InputMaybe<Scalars['Int']['input']>;\n  /** The ID of the parent menu object */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Registered menu locations */\nexport enum MenuLocationEnum {\n  /** Empty menu location */\n  EMPTY = 'EMPTY'\n}\n\n/** The Type of Identifier used to fetch a single node. Default is \"ID\". To be used along with the \"id\" field. */\nexport enum MenuNodeIdTypeEnum {\n  /** Identify a menu node by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a menu node by the (hashed) Global ID. */\n  ID = 'ID',\n  /** Identify a menu node by the slug of menu location to which it is assigned */\n  LOCATION = 'LOCATION',\n  /** Identify a menu node by its name */\n  NAME = 'NAME',\n  /** Identify a menu node by its slug */\n  SLUG = 'SLUG'\n}\n\n/** Arguments for filtering the MenuToMenuItemConnection connection */\nexport type MenuToMenuItemConnectionWhereArgs = {\n  /** The database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** The menu location for the menu being queried */\n  location?: InputMaybe<MenuLocationEnum>;\n  /** The database ID of the parent menu object */\n  parentDatabaseId?: InputMaybe<Scalars['Int']['input']>;\n  /** The ID of the parent menu object */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Meta data. */\nexport type MetaDataInput = {\n  /** Meta ID. */\n  id?: InputMaybe<Scalars['String']['input']>;\n  /** Meta key. */\n  key: Scalars['String']['input'];\n  /** Meta value. */\n  value: Scalars['String']['input'];\n};\n\n/** The MimeType of the object */\nexport enum MimeTypeEnum {\n  /** application/java mime type. */\n  APPLICATION_JAVA = 'APPLICATION_JAVA',\n  /** application/msword mime type. */\n  APPLICATION_MSWORD = 'APPLICATION_MSWORD',\n  /** application/octet-stream mime type. */\n  APPLICATION_OCTET_STREAM = 'APPLICATION_OCTET_STREAM',\n  /** application/onenote mime type. */\n  APPLICATION_ONENOTE = 'APPLICATION_ONENOTE',\n  /** application/oxps mime type. */\n  APPLICATION_OXPS = 'APPLICATION_OXPS',\n  /** application/pdf mime type. */\n  APPLICATION_PDF = 'APPLICATION_PDF',\n  /** application/rar mime type. */\n  APPLICATION_RAR = 'APPLICATION_RAR',\n  /** application/rtf mime type. */\n  APPLICATION_RTF = 'APPLICATION_RTF',\n  /** application/ttaf+xml mime type. */\n  APPLICATION_TTAF_XML = 'APPLICATION_TTAF_XML',\n  /** application/vnd.apple.keynote mime type. */\n  APPLICATION_VND_APPLE_KEYNOTE = 'APPLICATION_VND_APPLE_KEYNOTE',\n  /** application/vnd.apple.numbers mime type. */\n  APPLICATION_VND_APPLE_NUMBERS = 'APPLICATION_VND_APPLE_NUMBERS',\n  /** application/vnd.apple.pages mime type. */\n  APPLICATION_VND_APPLE_PAGES = 'APPLICATION_VND_APPLE_PAGES',\n  /** application/vnd.ms-access mime type. */\n  APPLICATION_VND_MS_ACCESS = 'APPLICATION_VND_MS_ACCESS',\n  /** application/vnd.ms-excel mime type. */\n  APPLICATION_VND_MS_EXCEL = 'APPLICATION_VND_MS_EXCEL',\n  /** application/vnd.ms-excel.addin.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_EXCEL_ADDIN_MACROENABLED_12 = 'APPLICATION_VND_MS_EXCEL_ADDIN_MACROENABLED_12',\n  /** application/vnd.ms-excel.sheet.binary.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_EXCEL_SHEET_BINARY_MACROENABLED_12 = 'APPLICATION_VND_MS_EXCEL_SHEET_BINARY_MACROENABLED_12',\n  /** application/vnd.ms-excel.sheet.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_EXCEL_SHEET_MACROENABLED_12 = 'APPLICATION_VND_MS_EXCEL_SHEET_MACROENABLED_12',\n  /** application/vnd.ms-excel.template.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_EXCEL_TEMPLATE_MACROENABLED_12 = 'APPLICATION_VND_MS_EXCEL_TEMPLATE_MACROENABLED_12',\n  /** application/vnd.ms-powerpoint mime type. */\n  APPLICATION_VND_MS_POWERPOINT = 'APPLICATION_VND_MS_POWERPOINT',\n  /** application/vnd.ms-powerpoint.addin.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_POWERPOINT_ADDIN_MACROENABLED_12 = 'APPLICATION_VND_MS_POWERPOINT_ADDIN_MACROENABLED_12',\n  /** application/vnd.ms-powerpoint.presentation.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_POWERPOINT_PRESENTATION_MACROENABLED_12 = 'APPLICATION_VND_MS_POWERPOINT_PRESENTATION_MACROENABLED_12',\n  /** application/vnd.ms-powerpoint.slideshow.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_POWERPOINT_SLIDESHOW_MACROENABLED_12 = 'APPLICATION_VND_MS_POWERPOINT_SLIDESHOW_MACROENABLED_12',\n  /** application/vnd.ms-powerpoint.slide.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_POWERPOINT_SLIDE_MACROENABLED_12 = 'APPLICATION_VND_MS_POWERPOINT_SLIDE_MACROENABLED_12',\n  /** application/vnd.ms-powerpoint.template.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_POWERPOINT_TEMPLATE_MACROENABLED_12 = 'APPLICATION_VND_MS_POWERPOINT_TEMPLATE_MACROENABLED_12',\n  /** application/vnd.ms-project mime type. */\n  APPLICATION_VND_MS_PROJECT = 'APPLICATION_VND_MS_PROJECT',\n  /** application/vnd.ms-word.document.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_WORD_DOCUMENT_MACROENABLED_12 = 'APPLICATION_VND_MS_WORD_DOCUMENT_MACROENABLED_12',\n  /** application/vnd.ms-word.template.macroEnabled.12 mime type. */\n  APPLICATION_VND_MS_WORD_TEMPLATE_MACROENABLED_12 = 'APPLICATION_VND_MS_WORD_TEMPLATE_MACROENABLED_12',\n  /** application/vnd.ms-write mime type. */\n  APPLICATION_VND_MS_WRITE = 'APPLICATION_VND_MS_WRITE',\n  /** application/vnd.ms-xpsdocument mime type. */\n  APPLICATION_VND_MS_XPSDOCUMENT = 'APPLICATION_VND_MS_XPSDOCUMENT',\n  /** application/vnd.oasis.opendocument.chart mime type. */\n  APPLICATION_VND_OASIS_OPENDOCUMENT_CHART = 'APPLICATION_VND_OASIS_OPENDOCUMENT_CHART',\n  /** application/vnd.oasis.opendocument.database mime type. */\n  APPLICATION_VND_OASIS_OPENDOCUMENT_DATABASE = 'APPLICATION_VND_OASIS_OPENDOCUMENT_DATABASE',\n  /** application/vnd.oasis.opendocument.formula mime type. */\n  APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA = 'APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA',\n  /** application/vnd.oasis.opendocument.graphics mime type. */\n  APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS = 'APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS',\n  /** application/vnd.oasis.opendocument.presentation mime type. */\n  APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION = 'APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION',\n  /** application/vnd.oasis.opendocument.spreadsheet mime type. */\n  APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET = 'APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET',\n  /** application/vnd.oasis.opendocument.text mime type. */\n  APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT = 'APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT',\n  /** application/vnd.openxmlformats-officedocument.presentationml.presentation mime type. */\n  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_PRESENTATION = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_PRESENTATION',\n  /** application/vnd.openxmlformats-officedocument.presentationml.slide mime type. */\n  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDE = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDE',\n  /** application/vnd.openxmlformats-officedocument.presentationml.slideshow mime type. */\n  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDESHOW = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDESHOW',\n  /** application/vnd.openxmlformats-officedocument.presentationml.template mime type. */\n  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_TEMPLATE = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_TEMPLATE',\n  /** application/vnd.openxmlformats-officedocument.spreadsheetml.sheet mime type. */\n  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_SHEET = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_SHEET',\n  /** application/vnd.openxmlformats-officedocument.spreadsheetml.template mime type. */\n  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_TEMPLATE = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_TEMPLATE',\n  /** application/vnd.openxmlformats-officedocument.wordprocessingml.document mime type. */\n  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_DOCUMENT = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_DOCUMENT',\n  /** application/vnd.openxmlformats-officedocument.wordprocessingml.template mime type. */\n  APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_TEMPLATE = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_TEMPLATE',\n  /** application/wordperfect mime type. */\n  APPLICATION_WORDPERFECT = 'APPLICATION_WORDPERFECT',\n  /** application/x-7z-compressed mime type. */\n  APPLICATION_X_7Z_COMPRESSED = 'APPLICATION_X_7Z_COMPRESSED',\n  /** application/x-gzip mime type. */\n  APPLICATION_X_GZIP = 'APPLICATION_X_GZIP',\n  /** application/x-tar mime type. */\n  APPLICATION_X_TAR = 'APPLICATION_X_TAR',\n  /** application/zip mime type. */\n  APPLICATION_ZIP = 'APPLICATION_ZIP',\n  /** audio/aac mime type. */\n  AUDIO_AAC = 'AUDIO_AAC',\n  /** audio/flac mime type. */\n  AUDIO_FLAC = 'AUDIO_FLAC',\n  /** audio/midi mime type. */\n  AUDIO_MIDI = 'AUDIO_MIDI',\n  /** audio/mpeg mime type. */\n  AUDIO_MPEG = 'AUDIO_MPEG',\n  /** audio/ogg mime type. */\n  AUDIO_OGG = 'AUDIO_OGG',\n  /** audio/wav mime type. */\n  AUDIO_WAV = 'AUDIO_WAV',\n  /** audio/x-matroska mime type. */\n  AUDIO_X_MATROSKA = 'AUDIO_X_MATROSKA',\n  /** audio/x-ms-wax mime type. */\n  AUDIO_X_MS_WAX = 'AUDIO_X_MS_WAX',\n  /** audio/x-ms-wma mime type. */\n  AUDIO_X_MS_WMA = 'AUDIO_X_MS_WMA',\n  /** audio/x-realaudio mime type. */\n  AUDIO_X_REALAUDIO = 'AUDIO_X_REALAUDIO',\n  /** image/avif mime type. */\n  IMAGE_AVIF = 'IMAGE_AVIF',\n  /** image/bmp mime type. */\n  IMAGE_BMP = 'IMAGE_BMP',\n  /** image/gif mime type. */\n  IMAGE_GIF = 'IMAGE_GIF',\n  /** image/heic mime type. */\n  IMAGE_HEIC = 'IMAGE_HEIC',\n  /** image/heic-sequence mime type. */\n  IMAGE_HEIC_SEQUENCE = 'IMAGE_HEIC_SEQUENCE',\n  /** image/heif mime type. */\n  IMAGE_HEIF = 'IMAGE_HEIF',\n  /** image/heif-sequence mime type. */\n  IMAGE_HEIF_SEQUENCE = 'IMAGE_HEIF_SEQUENCE',\n  /** image/jpeg mime type. */\n  IMAGE_JPEG = 'IMAGE_JPEG',\n  /** image/png mime type. */\n  IMAGE_PNG = 'IMAGE_PNG',\n  /** image/tiff mime type. */\n  IMAGE_TIFF = 'IMAGE_TIFF',\n  /** image/webp mime type. */\n  IMAGE_WEBP = 'IMAGE_WEBP',\n  /** image/x-icon mime type. */\n  IMAGE_X_ICON = 'IMAGE_X_ICON',\n  /** text/calendar mime type. */\n  TEXT_CALENDAR = 'TEXT_CALENDAR',\n  /** text/css mime type. */\n  TEXT_CSS = 'TEXT_CSS',\n  /** text/csv mime type. */\n  TEXT_CSV = 'TEXT_CSV',\n  /** text/plain mime type. */\n  TEXT_PLAIN = 'TEXT_PLAIN',\n  /** text/richtext mime type. */\n  TEXT_RICHTEXT = 'TEXT_RICHTEXT',\n  /** text/tab-separated-values mime type. */\n  TEXT_TAB_SEPARATED_VALUES = 'TEXT_TAB_SEPARATED_VALUES',\n  /** text/vtt mime type. */\n  TEXT_VTT = 'TEXT_VTT',\n  /** video/3gpp mime type. */\n  VIDEO_3GPP = 'VIDEO_3GPP',\n  /** video/3gpp2 mime type. */\n  VIDEO_3GPP2 = 'VIDEO_3GPP2',\n  /** video/avi mime type. */\n  VIDEO_AVI = 'VIDEO_AVI',\n  /** video/divx mime type. */\n  VIDEO_DIVX = 'VIDEO_DIVX',\n  /** video/mp4 mime type. */\n  VIDEO_MP4 = 'VIDEO_MP4',\n  /** video/mpeg mime type. */\n  VIDEO_MPEG = 'VIDEO_MPEG',\n  /** video/ogg mime type. */\n  VIDEO_OGG = 'VIDEO_OGG',\n  /** video/quicktime mime type. */\n  VIDEO_QUICKTIME = 'VIDEO_QUICKTIME',\n  /** video/webm mime type. */\n  VIDEO_WEBM = 'VIDEO_WEBM',\n  /** video/x-flv mime type. */\n  VIDEO_X_FLV = 'VIDEO_X_FLV',\n  /** video/x-matroska mime type. */\n  VIDEO_X_MATROSKA = 'VIDEO_X_MATROSKA',\n  /** video/x-ms-asf mime type. */\n  VIDEO_X_MS_ASF = 'VIDEO_X_MS_ASF',\n  /** video/x-ms-wm mime type. */\n  VIDEO_X_MS_WM = 'VIDEO_X_MS_WM',\n  /** video/x-ms-wmv mime type. */\n  VIDEO_X_MS_WMV = 'VIDEO_X_MS_WMV',\n  /** video/x-ms-wmx mime type. */\n  VIDEO_X_MS_WMX = 'VIDEO_X_MS_WMX'\n}\n\n/** The cardinality of the connection order */\nexport enum OrderEnum {\n  /** Sort the query result set in an ascending order */\n  ASC = 'ASC',\n  /** Sort the query result set in a descending order */\n  DESC = 'DESC'\n}\n\n/** The Type of Identifier used to fetch a single Order. Default is ID. */\nexport enum OrderIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID',\n  /** Order key. */\n  ORDER_KEY = 'ORDER_KEY'\n}\n\n/** Order status enumeration */\nexport enum OrderStatusEnum {\n  /** Cancelled */\n  CANCELLED = 'CANCELLED',\n  /** Draft */\n  CHECKOUT_DRAFT = 'CHECKOUT_DRAFT',\n  /** Completed */\n  COMPLETED = 'COMPLETED',\n  /** Failed */\n  FAILED = 'FAILED',\n  /** On hold */\n  ON_HOLD = 'ON_HOLD',\n  /** Pending payment */\n  PENDING = 'PENDING',\n  /** Processing */\n  PROCESSING = 'PROCESSING',\n  /** Refunded */\n  REFUNDED = 'REFUNDED'\n}\n\n/** Arguments for filtering the OrderToCommentConnection connection */\nexport type OrderToCommentConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Arguments for filtering the OrderToDownloadableItemConnection connection */\nexport type OrderToDownloadableItemConnectionWhereArgs = {\n  /** Limit results to downloadable items that can be downloaded now. */\n  active?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit results to downloadable items that are expired. */\n  expired?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit results to downloadable items that have downloads remaining. */\n  hasDownloadsRemaining?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the OrderToRefundConnection connection */\nexport type OrderToRefundConnectionWhereArgs = {\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to refunds from a specific group of order IDs. */\n  orderIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostTypeOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit results to those matching a string. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to refunds assigned a specific status. */\n  statuses?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Fields to order the Orders connection by */\nexport enum OrdersOrderByEnum {\n  /** Order by publish date */\n  DATE = 'DATE',\n  /** Order by date the order was completed */\n  DATE_COMPLETED = 'DATE_COMPLETED',\n  /** Order by date the order was paid */\n  DATE_PAID = 'DATE_PAID',\n  /** Order by order discount amount */\n  DISCOUNT = 'DISCOUNT',\n  /** Preserve the ID order given in the IN array */\n  IN = 'IN',\n  /** Order by the menu order value */\n  MENU_ORDER = 'MENU_ORDER',\n  /** Order by last modified date */\n  MODIFIED = 'MODIFIED',\n  /** Order by name */\n  NAME = 'NAME',\n  /** Preserve slug order given in the NAME_IN array */\n  NAME_IN = 'NAME_IN',\n  /** Order by order key */\n  ORDER_KEY = 'ORDER_KEY',\n  /** Order by parent ID */\n  PARENT = 'PARENT',\n  /** Order by slug */\n  SLUG = 'SLUG',\n  /** Order by order total */\n  TAX = 'TAX',\n  /** Order by order total */\n  TOTAL = 'TOTAL'\n}\n\n/** Options for ordering the connection */\nexport type OrdersOrderbyInput = {\n  field: OrdersOrderByEnum;\n  order?: InputMaybe<OrderEnum>;\n};\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum PageIdType {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID',\n  /** Identify a resource by the URI. */\n  URI = 'URI'\n}\n\n/** Arguments for filtering the PageToCommentConnection connection */\nexport type PageToCommentConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Arguments for filtering the PageToRevisionConnection connection */\nexport type PageToRevisionConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** The status of the WordPress plugin. */\nexport enum PluginStatusEnum {\n  /** The plugin is currently active. */\n  ACTIVE = 'ACTIVE',\n  /** The plugin is a drop-in plugin. */\n  DROP_IN = 'DROP_IN',\n  /** The plugin is currently inactive. */\n  INACTIVE = 'INACTIVE',\n  /** The plugin is a must-use plugin. */\n  MUST_USE = 'MUST_USE',\n  /** The plugin is technically active but was paused while loading. */\n  PAUSED = 'PAUSED',\n  /** The plugin was active recently. */\n  RECENTLY_ACTIVE = 'RECENTLY_ACTIVE',\n  /** The plugin has an upgrade available. */\n  UPGRADE = 'UPGRADE'\n}\n\n/** Set relationships between the post to categories */\nexport type PostCategoriesInput = {\n  /** If true, this will append the category to existing related categories. If false, this will replace existing relationships. Default true. */\n  append?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The input list of items to set. */\n  nodes?: InputMaybe<Array<InputMaybe<PostCategoriesNodeInput>>>;\n};\n\n/** List of categories to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */\nexport type PostCategoriesNodeInput = {\n  /** The description of the category. This field is used to set a description of the category if a new one is created during the mutation. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the category. If present, this will be used to connect to the post. If no existing category exists with this ID, no connection will be made. */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The name of the category. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the category. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum PostFormatIdType {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The name of the node */\n  NAME = 'NAME',\n  /** Url friendly name of the node */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI'\n}\n\n/** Arguments for filtering the PostFormatToContentNodeConnection connection */\nexport type PostFormatToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfPostFormatEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the PostFormatToPostConnection connection */\nexport type PostFormatToPostConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Category ID */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Use Category Slug */\n  categoryName?: InputMaybe<Scalars['String']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Tag Slug */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Use Tag ID */\n  tagId?: InputMaybe<Scalars['String']['input']>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag slugs, used to display objects from one tag AND another */\n  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of tag slugs, used to include objects in ANY specified tags */\n  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum PostIdType {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID',\n  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */\n  SLUG = 'SLUG',\n  /** Identify a resource by the URI. */\n  URI = 'URI'\n}\n\n/** The format of post field data. */\nexport enum PostObjectFieldFormatEnum {\n  /** Provide the field value directly from database. Null on unauthenticated requests. */\n  RAW = 'RAW',\n  /** Provide the field value as rendered by WordPress. Default. */\n  RENDERED = 'RENDERED'\n}\n\n/** The column to use when filtering by date */\nexport enum PostObjectsConnectionDateColumnEnum {\n  /** The date the comment was created in local time. */\n  DATE = 'DATE',\n  /** The most recent modification date of the comment. */\n  MODIFIED = 'MODIFIED'\n}\n\n/** Field to order the connection by */\nexport enum PostObjectsConnectionOrderbyEnum {\n  /** Order by author */\n  AUTHOR = 'AUTHOR',\n  /** Order by the number of comments it has acquired */\n  COMMENT_COUNT = 'COMMENT_COUNT',\n  /** Order by publish date */\n  DATE = 'DATE',\n  /** Preserve the ID order given in the IN array */\n  IN = 'IN',\n  /** Order by the menu order value */\n  MENU_ORDER = 'MENU_ORDER',\n  /** Order by last modified date */\n  MODIFIED = 'MODIFIED',\n  /** Preserve slug order given in the NAME_IN array */\n  NAME_IN = 'NAME_IN',\n  /** Order by parent ID */\n  PARENT = 'PARENT',\n  /** Order by slug */\n  SLUG = 'SLUG',\n  /** Order by title */\n  TITLE = 'TITLE'\n}\n\n/** Options for ordering the connection */\nexport type PostObjectsConnectionOrderbyInput = {\n  /** The field to order the connection by */\n  field: PostObjectsConnectionOrderbyEnum;\n  /** Possible directions in which to order a list of items */\n  order: OrderEnum;\n};\n\n/** Set relationships between the post to postFormats */\nexport type PostPostFormatsInput = {\n  /** If true, this will append the postFormat to existing related postFormats. If false, this will replace existing relationships. Default true. */\n  append?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The input list of items to set. */\n  nodes?: InputMaybe<Array<InputMaybe<PostPostFormatsNodeInput>>>;\n};\n\n/** List of postFormats to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */\nexport type PostPostFormatsNodeInput = {\n  /** The description of the postFormat. This field is used to set a description of the postFormat if a new one is created during the mutation. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the postFormat. If present, this will be used to connect to the post. If no existing postFormat exists with this ID, no connection will be made. */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The name of the postFormat. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the postFormat. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** The status of the object. */\nexport enum PostStatusEnum {\n  /** Objects with the acf-disabled status */\n  ACF_DISABLED = 'ACF_DISABLED',\n  /** Objects with the auto-draft status */\n  AUTO_DRAFT = 'AUTO_DRAFT',\n  /** Objects with the draft status */\n  DRAFT = 'DRAFT',\n  /** Objects with the future status */\n  FUTURE = 'FUTURE',\n  /** Objects with the inherit status */\n  INHERIT = 'INHERIT',\n  /** Objects with the pending status */\n  PENDING = 'PENDING',\n  /** Objects with the private status */\n  PRIVATE = 'PRIVATE',\n  /** Objects with the publish status */\n  PUBLISH = 'PUBLISH',\n  /** Objects with the request-completed status */\n  REQUEST_COMPLETED = 'REQUEST_COMPLETED',\n  /** Objects with the request-confirmed status */\n  REQUEST_CONFIRMED = 'REQUEST_CONFIRMED',\n  /** Objects with the request-failed status */\n  REQUEST_FAILED = 'REQUEST_FAILED',\n  /** Objects with the request-pending status */\n  REQUEST_PENDING = 'REQUEST_PENDING',\n  /** Objects with the trash status */\n  TRASH = 'TRASH',\n  /** Objects with the wc-cancelled status */\n  WC_CANCELLED = 'WC_CANCELLED',\n  /** Objects with the wc-checkout-draft status */\n  WC_CHECKOUT_DRAFT = 'WC_CHECKOUT_DRAFT',\n  /** Objects with the wc-completed status */\n  WC_COMPLETED = 'WC_COMPLETED',\n  /** Objects with the wc-failed status */\n  WC_FAILED = 'WC_FAILED',\n  /** Objects with the wc-on-hold status */\n  WC_ON_HOLD = 'WC_ON_HOLD',\n  /** Objects with the wc-pending status */\n  WC_PENDING = 'WC_PENDING',\n  /** Objects with the wc-processing status */\n  WC_PROCESSING = 'WC_PROCESSING',\n  /** Objects with the wc-refunded status */\n  WC_REFUNDED = 'WC_REFUNDED'\n}\n\n/** Set relationships between the post to tags */\nexport type PostTagsInput = {\n  /** If true, this will append the tag to existing related tags. If false, this will replace existing relationships. Default true. */\n  append?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The input list of items to set. */\n  nodes?: InputMaybe<Array<InputMaybe<PostTagsNodeInput>>>;\n};\n\n/** List of tags to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */\nexport type PostTagsNodeInput = {\n  /** The description of the tag. This field is used to set a description of the tag if a new one is created during the mutation. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the tag. If present, this will be used to connect to the post. If no existing tag exists with this ID, no connection will be made. */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The name of the tag. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the tag. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the PostToCategoryConnection connection */\nexport type PostToCategoryConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the PostToCommentConnection connection */\nexport type PostToCommentConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Arguments for filtering the PostToPostFormatConnection connection */\nexport type PostToPostFormatConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the PostToRevisionConnection connection */\nexport type PostToRevisionConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Category ID */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Use Category Slug */\n  categoryName?: InputMaybe<Scalars['String']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Tag Slug */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Use Tag ID */\n  tagId?: InputMaybe<Scalars['String']['input']>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag slugs, used to display objects from one tag AND another */\n  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of tag slugs, used to include objects in ANY specified tags */\n  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the PostToTagConnection connection */\nexport type PostToTagConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the PostToTermNodeConnection connection */\nexport type PostToTermNodeConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** The Taxonomy to filter terms by */\n  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Fields to order the PostType connection by */\nexport enum PostTypeOrderByEnum {\n  /** Order by publish date */\n  DATE = 'DATE',\n  /** Preserve the ID order given in the IN array */\n  IN = 'IN',\n  /** Order by the menu order value */\n  MENU_ORDER = 'MENU_ORDER',\n  /** Order by last modified date */\n  MODIFIED = 'MODIFIED',\n  /** Order by name */\n  NAME = 'NAME',\n  /** Preserve slug order given in the NAME_IN array */\n  NAME_IN = 'NAME_IN',\n  /** Order by parent ID */\n  PARENT = 'PARENT',\n  /** Order by slug */\n  SLUG = 'SLUG'\n}\n\n/** Options for ordering the connection */\nexport type PostTypeOrderbyInput = {\n  field: PostTypeOrderByEnum;\n  order?: InputMaybe<OrderEnum>;\n};\n\n/** Pricing field format enumeration */\nexport enum PricingFieldFormatEnum {\n  FORMATTED = 'FORMATTED',\n  RAW = 'RAW'\n}\n\n/** Product attribute taxonomies */\nexport enum ProductAttributeEnum {\n  NONE = 'NONE'\n}\n\n/** Product filter */\nexport type ProductAttributeFilterInput = {\n  /** A list of term ids */\n  ids?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Filter operation type */\n  operator?: InputMaybe<AttributeOperatorEnum>;\n  /** Which field to select taxonomy term by. */\n  taxonomy: ProductAttributeEnum;\n  /** A list of term slugs */\n  terms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Options for ordering the connection */\nexport type ProductAttributeInput = {\n  attributeName: Scalars['String']['input'];\n  attributeValue?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Product filter */\nexport type ProductAttributeQueryInput = {\n  /** Limit result set to products with selected global attributes. */\n  queries?: InputMaybe<Array<InputMaybe<ProductAttributeFilterInput>>>;\n  /** The logical relationship between attributes when filtering across multiple at once. */\n  relation?: InputMaybe<AttributeOperatorEnum>;\n};\n\n/** Product attribute type enumeration */\nexport enum ProductAttributeTypesEnum {\n  /** A global product attribute */\n  GLOBAL = 'GLOBAL',\n  /** A local product attribute */\n  LOCAL = 'LOCAL'\n}\n\n/** Product attributes connection orderby enum */\nexport enum ProductAttributesConnectionOrderbyEnum {\n  /** Order the connection by item count. */\n  COUNT = 'COUNT',\n  /** Order the connection by description. */\n  DESCRIPTION = 'DESCRIPTION',\n  /** Order the connection by woocommerce menu order. */\n  MENU_ORDER = 'MENU_ORDER',\n  /** Order the connection by name. */\n  NAME = 'NAME',\n  /** Order the connection by slug. */\n  SLUG = 'SLUG',\n  /** Order the connection by term group. */\n  TERM_GROUP = 'TERM_GROUP',\n  /** Order the connection by term id. */\n  TERM_ID = 'TERM_ID',\n  /** Order the connection by term order. */\n  TERM_ORDER = 'TERM_ORDER'\n}\n\n/** Product category display type enumeration */\nexport enum ProductCategoryDisplay {\n  /** Display both products and subcategories of this category. */\n  BOTH = 'BOTH',\n  /** Display default content connected to this category. */\n  DEFAULT = 'DEFAULT',\n  /** Display products associated with this category. */\n  PRODUCTS = 'PRODUCTS',\n  /** Display subcategories of this category. */\n  SUBCATEGORIES = 'SUBCATEGORIES'\n}\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum ProductCategoryIdType {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The name of the node */\n  NAME = 'NAME',\n  /** Url friendly name of the node */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI'\n}\n\n/** Arguments for filtering the ProductCategoryToContentNodeConnection connection */\nexport type ProductCategoryToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfProductCategoryEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the ProductCategoryToProductCategoryConnection connection */\nexport type ProductCategoryToProductCategoryConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the ProductCategoryToProductConnection connection */\nexport type ProductCategoryToProductConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** The Type of Identifier used to fetch a single Product. Default is ID. */\nexport enum ProductIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID',\n  /** Unique store identifier for product. */\n  SKU = 'SKU',\n  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */\n  SLUG = 'SLUG'\n}\n\n/** Set relationships between the Product to productCategories */\nexport type ProductProductCategoriesInput = {\n  /** If true, this will append the productCategory to existing related productCategories. If false, this will replace existing relationships. Default true. */\n  append?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The input list of items to set. */\n  nodes?: InputMaybe<Array<InputMaybe<ProductProductCategoriesNodeInput>>>;\n};\n\n/** List of productCategories to connect the Product to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */\nexport type ProductProductCategoriesNodeInput = {\n  /** The description of the productCategory. This field is used to set a description of the productCategory if a new one is created during the mutation. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the productCategory. If present, this will be used to connect to the Product. If no existing productCategory exists with this ID, no connection will be made. */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The name of the productCategory. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the productCategory. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Set relationships between the Product to productTags */\nexport type ProductProductTagsInput = {\n  /** If true, this will append the productTag to existing related productTags. If false, this will replace existing relationships. Default true. */\n  append?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The input list of items to set. */\n  nodes?: InputMaybe<Array<InputMaybe<ProductProductTagsNodeInput>>>;\n};\n\n/** List of productTags to connect the Product to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */\nexport type ProductProductTagsNodeInput = {\n  /** The description of the productTag. This field is used to set a description of the productTag if a new one is created during the mutation. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the productTag. If present, this will be used to connect to the Product. If no existing productTag exists with this ID, no connection will be made. */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The name of the productTag. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the productTag. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Set relationships between the Product to productTypes */\nexport type ProductProductTypesInput = {\n  /** If true, this will append the productType to existing related productTypes. If false, this will replace existing relationships. Default true. */\n  append?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The input list of items to set. */\n  nodes?: InputMaybe<Array<InputMaybe<ProductProductTypesNodeInput>>>;\n};\n\n/** List of productTypes to connect the Product to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */\nexport type ProductProductTypesNodeInput = {\n  /** The description of the productType. This field is used to set a description of the productType if a new one is created during the mutation. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the productType. If present, this will be used to connect to the Product. If no existing productType exists with this ID, no connection will be made. */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The name of the productType. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the productType. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Set relationships between the Product to shippingClasses */\nexport type ProductShippingClassesInput = {\n  /** If true, this will append the shippingClass to existing related shippingClasses. If false, this will replace existing relationships. Default true. */\n  append?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The input list of items to set. */\n  nodes?: InputMaybe<Array<InputMaybe<ProductShippingClassesNodeInput>>>;\n};\n\n/** List of shippingClasses to connect the Product to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */\nexport type ProductShippingClassesNodeInput = {\n  /** The description of the shippingClass. This field is used to set a description of the shippingClass if a new one is created during the mutation. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the shippingClass. If present, this will be used to connect to the Product. If no existing shippingClass exists with this ID, no connection will be made. */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The name of the shippingClass. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the shippingClass. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum ProductTagIdType {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The name of the node */\n  NAME = 'NAME',\n  /** Url friendly name of the node */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI'\n}\n\n/** Arguments for filtering the ProductTagToContentNodeConnection connection */\nexport type ProductTagToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfProductTagEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the ProductTagToProductConnection connection */\nexport type ProductTagToProductConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Product taxonomies */\nexport enum ProductTaxonomyEnum {\n  PRODUCT_CAT = 'PRODUCT_CAT',\n  PRODUCT_SHIPPING_CLASS = 'PRODUCT_SHIPPING_CLASS',\n  PRODUCT_TAG = 'PRODUCT_TAG',\n  PRODUCT_TYPE = 'PRODUCT_TYPE',\n  PRODUCT_VISIBILITY = 'PRODUCT_VISIBILITY'\n}\n\n/** Product filter */\nexport type ProductTaxonomyFilterInput = {\n  /** A list of term ids */\n  ids?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Filter operation type */\n  operator?: InputMaybe<TaxonomyOperatorEnum>;\n  /** Which field to select taxonomy term by. */\n  taxonomy: ProductTaxonomyEnum;\n  /** A list of term slugs */\n  terms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Product taxonomy filter type */\nexport type ProductTaxonomyInput = {\n  /** Product taxonomy rules to be filter results by */\n  filters?: InputMaybe<Array<InputMaybe<ProductTaxonomyFilterInput>>>;\n  /** Logic relation between each filter. */\n  relation?: InputMaybe<RelationEnum>;\n};\n\n/** Arguments for filtering the ProductToCommentConnection connection */\nexport type ProductToCommentConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Arguments for filtering the ProductToCommentsConnection connection */\nexport type ProductToCommentsConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Arguments for filtering the ProductToMediaItemConnection connection */\nexport type ProductToMediaItemConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the ProductToParentConnection connection */\nexport type ProductToParentConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Arguments for filtering the ProductToPreviewConnection connection */\nexport type ProductToPreviewConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Arguments for filtering the ProductToProductAttributeConnection connection */\nexport type ProductToProductAttributeConnectionWhereArgs = {\n  /** Filter results by attribute scope. */\n  type?: InputMaybe<ProductAttributeTypesEnum>;\n};\n\n/** Arguments for filtering the ProductToProductCategoryConnection connection */\nexport type ProductToProductCategoryConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the ProductToProductConnection connection */\nexport type ProductToProductConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Arguments for filtering the ProductToProductTagConnection connection */\nexport type ProductToProductTagConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the ProductToProductTypeConnection connection */\nexport type ProductToProductTypeConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the ProductToProductUnionConnection connection */\nexport type ProductToProductUnionConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Shuffle results? (Pagination currently not support by this argument) */\n  shuffle?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Arguments for filtering the ProductToShippingClassConnection connection */\nexport type ProductToShippingClassConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the ProductToTermNodeConnection connection */\nexport type ProductToTermNodeConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** The Taxonomy to filter terms by */\n  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the ProductToUpsellConnection connection */\nexport type ProductToUpsellConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Arguments for filtering the ProductToVisibleProductConnection connection */\nexport type ProductToVisibleProductConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum ProductTypeIdType {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The name of the node */\n  NAME = 'NAME',\n  /** Url friendly name of the node */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI'\n}\n\n/** Arguments for filtering the ProductTypeToContentNodeConnection connection */\nexport type ProductTypeToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfProductTypeEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the ProductTypeToProductConnection connection */\nexport type ProductTypeToProductConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Product type enumeration */\nexport enum ProductTypesEnum {\n  /** An external product */\n  EXTERNAL = 'EXTERNAL',\n  /** A product group */\n  GROUPED = 'GROUPED',\n  /** A simple product */\n  SIMPLE = 'SIMPLE',\n  /** A variable product */\n  VARIABLE = 'VARIABLE',\n  /** A product variation */\n  VARIATION = 'VARIATION'\n}\n\n/** The Type of Identifier used to fetch a single ProductVariation. Default is ID. */\nexport enum ProductVariationIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID'\n}\n\n/** Set relationships between the Product to visibleProducts */\nexport type ProductVisibleProductsInput = {\n  /** If true, this will append the visibleProduct to existing related visibleProducts. If false, this will replace existing relationships. Default true. */\n  append?: InputMaybe<Scalars['Boolean']['input']>;\n  /** The input list of items to set. */\n  nodes?: InputMaybe<Array<InputMaybe<ProductVisibleProductsNodeInput>>>;\n};\n\n/** List of visibleProducts to connect the Product to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */\nexport type ProductVisibleProductsNodeInput = {\n  /** The description of the visibleProduct. This field is used to set a description of the visibleProduct if a new one is created during the mutation. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the visibleProduct. If present, this will be used to connect to the Product. If no existing visibleProduct exists with this ID, no connection will be made. */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** The name of the visibleProduct. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the visibleProduct. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the ProductWithVariationsToProductVariationConnection connection */\nexport type ProductWithVariationsToProductVariationConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Fields to order the Products connection by */\nexport enum ProductsOrderByEnum {\n  /** Order by publish date */\n  DATE = 'DATE',\n  /** Preserve the ID order given in the IN array */\n  IN = 'IN',\n  /** Order by the menu order value */\n  MENU_ORDER = 'MENU_ORDER',\n  /** Order by last modified date */\n  MODIFIED = 'MODIFIED',\n  /** Order by name */\n  NAME = 'NAME',\n  /** Preserve slug order given in the NAME_IN array */\n  NAME_IN = 'NAME_IN',\n  /**\n   * Order by date product sale starts\n   * @deprecated This field is deprecated and will be removed in a future version.\n   */\n  ON_SALE_FROM = 'ON_SALE_FROM',\n  /**\n   * Order by date product sale ends\n   * @deprecated This field is deprecated and will be removed in a future version.\n   */\n  ON_SALE_TO = 'ON_SALE_TO',\n  /** Order by parent ID */\n  PARENT = 'PARENT',\n  /** Order by product popularity */\n  POPULARITY = 'POPULARITY',\n  /** Order by product's current price */\n  PRICE = 'PRICE',\n  /** Order by product average rating */\n  RATING = 'RATING',\n  /**\n   * Order by product's regular price\n   * @deprecated This field is deprecated and will be removed in a future version. Use \"PRICE\" instead.\n   */\n  REGULAR_PRICE = 'REGULAR_PRICE',\n  /** Order by number of reviews on product */\n  REVIEW_COUNT = 'REVIEW_COUNT',\n  /**\n   * Order by product's sale price\n   * @deprecated This field is deprecated and will be removed in a future version. Use \"PRICE\" instead.\n   */\n  SALE_PRICE = 'SALE_PRICE',\n  /** Order by slug */\n  SLUG = 'SLUG',\n  /**\n   * Order by total sales of products sold\n   * @deprecated This field is deprecated and will be removed in a future version. Use \"POPULARITY\" instead\n   */\n  TOTAL_SALES = 'TOTAL_SALES'\n}\n\n/** Options for ordering the connection */\nexport type ProductsOrderbyInput = {\n  field: ProductsOrderByEnum;\n  order?: InputMaybe<OrderEnum>;\n};\n\n/** The Type of Identifier used to fetch a single Refund. Default is ID. */\nexport enum RefundIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID'\n}\n\n/** Input for the registerCustomer mutation. */\nexport type RegisterCustomerInput = {\n  /** User's AOL IM account. */\n  aim?: InputMaybe<Scalars['String']['input']>;\n  /** Customer billing information */\n  billing?: InputMaybe<CustomerAddressInput>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing content about the user. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user). */\n  displayName?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing the user's email address. */\n  email?: InputMaybe<Scalars['String']['input']>;\n  /** \tThe user's first name. */\n  firstName?: InputMaybe<Scalars['String']['input']>;\n  /** User's Jabber account. */\n  jabber?: InputMaybe<Scalars['String']['input']>;\n  /** The user's last name. */\n  lastName?: InputMaybe<Scalars['String']['input']>;\n  /** User's locale. */\n  locale?: InputMaybe<Scalars['String']['input']>;\n  /** Meta data. */\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n  /** A string that contains a URL-friendly name for the user. The default is the user's username. */\n  nicename?: InputMaybe<Scalars['String']['input']>;\n  /** The user's nickname, defaults to the user's username. */\n  nickname?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains the plain text password for the user. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** The date the user registered. Format is Y-m-d H:i:s. */\n  registered?: InputMaybe<Scalars['String']['input']>;\n  /** A string for whether to enable the rich editor or not. False if not empty. */\n  richEditing?: InputMaybe<Scalars['String']['input']>;\n  /** Customer shipping address */\n  shipping?: InputMaybe<CustomerAddressInput>;\n  /** Customer shipping is identical to billing address */\n  shippingSameAsBilling?: InputMaybe<Scalars['Boolean']['input']>;\n  /** A string that contains the user's username. */\n  username?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing the user's URL for the user's web site. */\n  websiteUrl?: InputMaybe<Scalars['String']['input']>;\n  /** User's Yahoo IM account. */\n  yim?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the registerUser mutation. */\nexport type RegisterUserInput = {\n  /** User's AOL IM account. */\n  aim?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing content about the user. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user). */\n  displayName?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing the user's email address. */\n  email?: InputMaybe<Scalars['String']['input']>;\n  /** \tThe user's first name. */\n  firstName?: InputMaybe<Scalars['String']['input']>;\n  /** User's Jabber account. */\n  jabber?: InputMaybe<Scalars['String']['input']>;\n  /** The user's last name. */\n  lastName?: InputMaybe<Scalars['String']['input']>;\n  /** User's locale. */\n  locale?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains a URL-friendly name for the user. The default is the user's username. */\n  nicename?: InputMaybe<Scalars['String']['input']>;\n  /** The user's nickname, defaults to the user's username. */\n  nickname?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains the plain text password for the user. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** The date the user registered. Format is Y-m-d H:i:s. */\n  registered?: InputMaybe<Scalars['String']['input']>;\n  /** A string for whether to enable the rich editor or not. False if not empty. */\n  richEditing?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains the user's username. */\n  username: Scalars['String']['input'];\n  /** A string containing the user's URL for the user's web site. */\n  websiteUrl?: InputMaybe<Scalars['String']['input']>;\n  /** User's Yahoo IM account. */\n  yim?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** The logical relation between each item in the array when there are more than one. */\nexport enum RelationEnum {\n  /** The logical AND condition returns true if both operands are true, otherwise, it returns false. */\n  AND = 'AND',\n  /** The logical OR condition returns false if both operands are false, otherwise, it returns true. */\n  OR = 'OR'\n}\n\n/** Input for the removeCoupons mutation. */\nexport type RemoveCouponsInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Code of coupon being applied */\n  codes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Input for the removeItemsFromCart mutation. */\nexport type RemoveItemsFromCartInput = {\n  /** Remove all cart items */\n  all?: InputMaybe<Scalars['Boolean']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Item keys of the items being removed */\n  keys?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n};\n\n/** Input for the removeMethodFromShippingZone mutation. */\nexport type RemoveMethodFromShippingZoneInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Shipping method instance ID */\n  instanceId: Scalars['Int']['input'];\n  /** The ID of the shipping zone to delete. */\n  zoneId: Scalars['Int']['input'];\n};\n\n/** Input for the resetUserPassword mutation. */\nexport type ResetUserPasswordInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Password reset key */\n  key?: InputMaybe<Scalars['String']['input']>;\n  /** The user's login (username). */\n  login?: InputMaybe<Scalars['String']['input']>;\n  /** The new password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the restoreCartItems mutation. */\nexport type RestoreCartItemsInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Cart item key of the item being removed */\n  keys?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n};\n\n/** Input for the restoreComment mutation. */\nexport type RestoreCommentInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the comment to be restored */\n  id: Scalars['ID']['input'];\n};\n\n/** Input for the restoreReview mutation. */\nexport type RestoreReviewInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the target product review */\n  id: Scalars['ID']['input'];\n};\n\n/** Arguments for filtering the RootQueryToCategoryConnection connection */\nexport type RootQueryToCategoryConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToCommentConnection connection */\nexport type RootQueryToCommentConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToContentNodeConnection connection */\nexport type RootQueryToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToCouponConnection connection */\nexport type RootQueryToCouponConnectionWhereArgs = {\n  /** Limit result set to resources with a specific code. */\n  code?: InputMaybe<Scalars['String']['input']>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostTypeOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit results to those matching a string. */\n  search?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToCustomerConnection connection */\nexport type RootQueryToCustomerConnectionWhereArgs = {\n  /** Limit result set to resources with a specific email. */\n  email?: InputMaybe<Scalars['String']['input']>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Order of results. */\n  order?: InputMaybe<OrderEnum>;\n  /** Order results by a specific field. */\n  orderby?: InputMaybe<CustomerConnectionOrderbyEnum>;\n  /** Limit results to those matching a string. */\n  search?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToMediaItemConnection connection */\nexport type RootQueryToMediaItemConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToMenuConnection connection */\nexport type RootQueryToMenuConnectionWhereArgs = {\n  /** The database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** The menu location for the menu being queried */\n  location?: InputMaybe<MenuLocationEnum>;\n  /** The slug of the menu to query items for */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToMenuItemConnection connection */\nexport type RootQueryToMenuItemConnectionWhereArgs = {\n  /** The database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** The menu location for the menu being queried */\n  location?: InputMaybe<MenuLocationEnum>;\n  /** The database ID of the parent menu object */\n  parentDatabaseId?: InputMaybe<Scalars['Int']['input']>;\n  /** The ID of the parent menu object */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToOrderConnection connection */\nexport type RootQueryToOrderConnectionWhereArgs = {\n  /** Limit result set to orders assigned a specific billing email. */\n  billingEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to orders assigned a specific customer. */\n  customerId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to orders assigned a specific group of customers. */\n  customersIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<OrdersOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to orders assigned a specific product. */\n  productId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit results to those matching a string. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to orders assigned a specific status. */\n  statuses?: InputMaybe<Array<InputMaybe<OrderStatusEnum>>>;\n};\n\n/** Arguments for filtering the RootQueryToPageConnection connection */\nexport type RootQueryToPageConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToPaymentGatewayConnection connection */\nexport type RootQueryToPaymentGatewayConnectionWhereArgs = {\n  /** Include disabled payment gateways? */\n  all?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToPluginConnection connection */\nexport type RootQueryToPluginConnectionWhereArgs = {\n  /** Show plugin based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve plugins where plugin status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PluginStatusEnum>>>;\n  /** Show plugins with a specific status. */\n  status?: InputMaybe<PluginStatusEnum>;\n};\n\n/** Arguments for filtering the RootQueryToPostConnection connection */\nexport type RootQueryToPostConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Category ID */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Use Category Slug */\n  categoryName?: InputMaybe<Scalars['String']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Tag Slug */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Use Tag ID */\n  tagId?: InputMaybe<Scalars['String']['input']>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag slugs, used to display objects from one tag AND another */\n  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of tag slugs, used to include objects in ANY specified tags */\n  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToPostFormatConnection connection */\nexport type RootQueryToPostFormatConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToProductCategoryConnection connection */\nexport type RootQueryToProductCategoryConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToProductTagConnection connection */\nexport type RootQueryToProductTagConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToProductTypeConnection connection */\nexport type RootQueryToProductTypeConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToProductUnionConnection connection */\nexport type RootQueryToProductUnionConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Arguments for filtering the RootQueryToRefundConnection connection */\nexport type RootQueryToRefundConnectionWhereArgs = {\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to refunds from a specific group of order IDs. */\n  orderIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostTypeOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit results to those matching a string. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to refunds assigned a specific status. */\n  statuses?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Arguments for filtering the RootQueryToRevisionsConnection connection */\nexport type RootQueryToRevisionsConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToShippingClassConnection connection */\nexport type RootQueryToShippingClassConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToTagConnection connection */\nexport type RootQueryToTagConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToTaxRateConnection connection */\nexport type RootQueryToTaxRateConnectionWhereArgs = {\n  /** Sort by tax class. */\n  class?: InputMaybe<TaxClassEnum>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<TaxRateConnectionOrderbyInput>>>;\n  /** Filter results by a post code. */\n  postCode?: InputMaybe<Scalars['String']['input']>;\n  /** Filter results by a group of post codes. */\n  postCodeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Arguments for filtering the RootQueryToTermNodeConnection connection */\nexport type RootQueryToTermNodeConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** The Taxonomy to filter terms by */\n  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Arguments for filtering the RootQueryToUserConnection connection */\nexport type RootQueryToUserConnectionWhereArgs = {\n  /** Array of userIds to exclude. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Pass an array of post types to filter results to users who have published posts in those post types. */\n  hasPublishedPosts?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of userIds to include. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** The user login. */\n  login?: InputMaybe<Scalars['String']['input']>;\n  /** An array of logins to include. Users matching one of these logins will be included in results. */\n  loginIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** An array of logins to exclude. Users matching one of these logins will not be included in results. */\n  loginNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** The user nicename. */\n  nicename?: InputMaybe<Scalars['String']['input']>;\n  /** An array of nicenames to include. Users matching one of these nicenames will be included in results. */\n  nicenameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** An array of nicenames to exclude. Users matching one of these nicenames will not be included in results. */\n  nicenameNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<UsersConnectionOrderbyInput>>>;\n  /** An array of role names that users must match to be included in results. Note that this is an inclusive list: users must match *each* role. */\n  role?: InputMaybe<UserRoleEnum>;\n  /** An array of role names. Matched users must have at least one of these roles. */\n  roleIn?: InputMaybe<Array<InputMaybe<UserRoleEnum>>>;\n  /** An array of role names to exclude. Users matching one or more of these roles will not be included in results. */\n  roleNotIn?: InputMaybe<Array<InputMaybe<UserRoleEnum>>>;\n  /** Search keyword. Searches for possible string matches on columns. When \"searchColumns\" is left empty, it tries to determine which column to search in based on search string. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of column names to be searched. Accepts 'ID', 'login', 'nicename', 'email', 'url'. */\n  searchColumns?: InputMaybe<Array<InputMaybe<UsersConnectionSearchColumnEnum>>>;\n};\n\n/** Arguments for filtering the RootQueryToVisibleProductConnection connection */\nexport type RootQueryToVisibleProductConnectionWhereArgs = {\n  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */\n  cacheDomain?: InputMaybe<Scalars['String']['input']>;\n  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */\n  childOf?: InputMaybe<Scalars['Int']['input']>;\n  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */\n  childless?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Retrieve terms where the description is LIKE the input value. Default empty. */\n  descriptionLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */\n  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */\n  hierarchical?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Array of term ids to include. Default empty array. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of names to return term(s) for. Default empty. */\n  name?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Retrieve terms where the name is LIKE the input value. Default empty. */\n  nameLike?: InputMaybe<Scalars['String']['input']>;\n  /** Array of object IDs. Results will be limited to terms associated with these objects. */\n  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Direction the connection should be ordered in */\n  order?: InputMaybe<OrderEnum>;\n  /** Field(s) to order terms by. Defaults to 'name'. */\n  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;\n  /** Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false. */\n  padCounts?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Parent term ID to retrieve direct-child terms of. Default empty. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Array of slugs to return term(s) for. Default empty. */\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of term taxonomy IDs, to match when querying terms. */\n  termTaxonomyId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Whether to prime meta caches for matched terms. Default true. */\n  updateTermMetaCache?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** The strategy to use when loading the script */\nexport enum ScriptLoadingStrategyEnum {\n  /** Use the script `async` attribute */\n  ASYNC = 'ASYNC',\n  /** Use the script `defer` attribute */\n  DEFER = 'DEFER'\n}\n\n/** Input for the sendPasswordResetEmail mutation. */\nexport type SendPasswordResetEmailInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains the user's username or email address. */\n  username: Scalars['String']['input'];\n};\n\n/** Input for the setDefaultPaymentMethod mutation. */\nexport type SetDefaultPaymentMethodInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Token ID of the payment token being deleted. */\n  tokenId: Scalars['Int']['input'];\n};\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum ShippingClassIdType {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The name of the node */\n  NAME = 'NAME',\n  /** Url friendly name of the node */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI'\n}\n\n/** Arguments for filtering the ShippingClassToContentNodeConnection connection */\nexport type ShippingClassToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfShippingClassEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the ShippingClassToProductConnection connection */\nexport type ShippingClassToProductConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Shipping lines data. */\nexport type ShippingLineInput = {\n  /** Shipping Line ID */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** Shipping instance ID. */\n  instanceId?: InputMaybe<Scalars['String']['input']>;\n  /** Meta data. */\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n  /** Shipping method ID. */\n  methodId: Scalars['String']['input'];\n  /** Shipping method name. */\n  methodTitle: Scalars['String']['input'];\n  /** Line total (after discounts). */\n  total: Scalars['String']['input'];\n};\n\n/** Shipping lines data. */\nexport type ShippingLocationInput = {\n  /** Shipping location code. */\n  code?: InputMaybe<Scalars['String']['input']>;\n  /** Shipping location type. */\n  type?: InputMaybe<ShippingLocationTypeEnum>;\n};\n\n/** A Shipping zone location type. */\nexport enum ShippingLocationTypeEnum {\n  CONTINENT = 'CONTINENT',\n  COUNTRY = 'COUNTRY',\n  POSTCODE = 'POSTCODE',\n  STATE = 'STATE'\n}\n\n/** The Type of Identifier used to fetch a single Shipping Method. Default is ID. */\nexport enum ShippingMethodIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID'\n}\n\n/** The Type of Identifier used to fetch a single Shipping Zone. Default is ID. */\nexport enum ShippingZoneIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID'\n}\n\n/** Arguments for filtering the SimpleProductToProductUnionConnection connection */\nexport type SimpleProductToProductUnionConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** Product stock status enumeration */\nexport enum StockStatusEnum {\n  IN_STOCK = 'IN_STOCK',\n  ON_BACKORDER = 'ON_BACKORDER',\n  OUT_OF_STOCK = 'OUT_OF_STOCK'\n}\n\n/** The Stripe Payment Method. Payment or Setup. */\nexport enum StripePaymentMethodEnum {\n  PAYMENT = 'PAYMENT',\n  SETUP = 'SETUP'\n}\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum TagIdType {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The name of the node */\n  NAME = 'NAME',\n  /** Url friendly name of the node */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI'\n}\n\n/** Arguments for filtering the TagToContentNodeConnection connection */\nexport type TagToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfTagEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the TagToPostConnection connection */\nexport type TagToPostConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Category ID */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Use Category Slug */\n  categoryName?: InputMaybe<Scalars['String']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Tag Slug */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Use Tag ID */\n  tagId?: InputMaybe<Scalars['String']['input']>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag slugs, used to display objects from one tag AND another */\n  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of tag slugs, used to include objects in ANY specified tags */\n  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Tax class enumeration */\nexport enum TaxClassEnum {\n  /** Inherits Tax class from cart */\n  INHERIT_CART = 'INHERIT_CART',\n  REDUCED_RATE = 'REDUCED_RATE',\n  /** Standard Tax rate */\n  STANDARD = 'STANDARD',\n  ZERO_RATE = 'ZERO_RATE'\n}\n\n/** Field to order the connection by */\nexport enum TaxRateConnectionOrderbyEnum {\n  ID = 'ID',\n  ORDER = 'ORDER'\n}\n\n/** Options for ordering the connection */\nexport type TaxRateConnectionOrderbyInput = {\n  field: TaxRateConnectionOrderbyEnum;\n  order?: InputMaybe<OrderEnum>;\n};\n\n/** The Type of Identifier used to fetch a single Tax rate. Default is ID. */\nexport enum TaxRateIdTypeEnum {\n  /** Identify a resource by the Database ID. */\n  DATABASE_ID = 'DATABASE_ID',\n  /** Identify a resource by the (hashed) Global ID. */\n  ID = 'ID'\n}\n\n/** Product tax status enumeration */\nexport enum TaxStatusEnum {\n  NONE = 'NONE',\n  SHIPPING = 'SHIPPING',\n  TAXABLE = 'TAXABLE'\n}\n\n/** Allowed taxonomies */\nexport enum TaxonomyEnum {\n  /** Taxonomy enum category */\n  CATEGORY = 'CATEGORY',\n  /** Taxonomy enum post_format */\n  POSTFORMAT = 'POSTFORMAT',\n  /** Taxonomy enum product_cat */\n  PRODUCTCATEGORY = 'PRODUCTCATEGORY',\n  /** Taxonomy enum product_tag */\n  PRODUCTTAG = 'PRODUCTTAG',\n  /** Taxonomy enum product_type */\n  PRODUCTTYPE = 'PRODUCTTYPE',\n  /** Taxonomy enum product_shipping_class */\n  SHIPPINGCLASS = 'SHIPPINGCLASS',\n  /** Taxonomy enum post_tag */\n  TAG = 'TAG',\n  /** Taxonomy enum product_visibility */\n  VISIBLEPRODUCT = 'VISIBLEPRODUCT'\n}\n\n/** The Type of Identifier used to fetch a single Taxonomy node. To be used along with the \"id\" field. Default is \"ID\". */\nexport enum TaxonomyIdTypeEnum {\n  /** The globally unique ID */\n  ID = 'ID',\n  /** The name of the taxonomy */\n  NAME = 'NAME'\n}\n\n/** Taxonomy query operators */\nexport enum TaxonomyOperatorEnum {\n  AND = 'AND',\n  EXISTS = 'EXISTS',\n  IN = 'IN',\n  NOT_EXISTS = 'NOT_EXISTS',\n  NOT_IN = 'NOT_IN'\n}\n\n/** The Type of Identifier used to fetch a single resource. Default is \"ID\". To be used along with the \"id\" field. */\nexport enum TermNodeIdTypeEnum {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The name of the node */\n  NAME = 'NAME',\n  /** Url friendly name of the node */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI'\n}\n\n/** Options for ordering the connection by */\nexport enum TermObjectsConnectionOrderbyEnum {\n  /** Order the connection by item count. */\n  COUNT = 'COUNT',\n  /** Order the connection by description. */\n  DESCRIPTION = 'DESCRIPTION',\n  /** Order the connection by name. */\n  NAME = 'NAME',\n  /** Order the connection by slug. */\n  SLUG = 'SLUG',\n  /** Order the connection by term group. */\n  TERM_GROUP = 'TERM_GROUP',\n  /** Order the connection by term id. */\n  TERM_ID = 'TERM_ID',\n  /** Order the connection by term order. */\n  TERM_ORDER = 'TERM_ORDER'\n}\n\n/** Input for the updateCategory mutation. */\nexport type UpdateCategoryInput = {\n  /** The slug that the category will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the category object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the category object to update */\n  id: Scalars['ID']['input'];\n  /** The name of the category object to mutate */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the category that should be set as the parent */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateComment mutation. */\nexport type UpdateCommentInput = {\n  /** The approval status of the comment. */\n  approved?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the comment's author. */\n  author?: InputMaybe<Scalars['String']['input']>;\n  /** The email of the comment's author. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** The url of the comment's author. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The database ID of the post object the comment belongs to. */\n  commentOn?: InputMaybe<Scalars['Int']['input']>;\n  /** Content of the comment. */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the comment being updated. */\n  id: Scalars['ID']['input'];\n  /** Parent comment ID of current comment. */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** The approval status of the comment */\n  status?: InputMaybe<CommentStatusEnum>;\n  /** Type of comment. */\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateCoupon mutation. */\nexport type UpdateCouponInput = {\n  /** The amount of discount. Should always be numeric, even if setting a percentage. */\n  amount?: InputMaybe<Scalars['Float']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Coupon code. */\n  code?: InputMaybe<Scalars['String']['input']>;\n  /** The date the coupon expires, in the site's timezone. */\n  dateExpires?: InputMaybe<Scalars['String']['input']>;\n  /** The date the coupon expires, as GMT. */\n  dateExpiresGmt?: InputMaybe<Scalars['String']['input']>;\n  /** Coupon description. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** Determines the type of discount that will be applied. */\n  discountType?: InputMaybe<DiscountTypeEnum>;\n  /** List of email addresses that can use this coupon. */\n  emailRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** If true, this coupon will not be applied to items that have sale prices. */\n  excludeSaleItems?: InputMaybe<Scalars['Boolean']['input']>;\n  /** List of category IDs the coupon does not apply to. */\n  excludedProductCategories?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** List of product IDs the coupon cannot be used on. */\n  excludedProductIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** If true and if the free shipping method requires a coupon, this coupon will enable free shipping. */\n  freeShipping?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Unique identifier for the object. */\n  id: Scalars['ID']['input'];\n  /** If true, the coupon can only be used individually. Other applied coupons will be removed from the cart. */\n  individualUse?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Max number of items in the cart the coupon can be applied to. */\n  limitUsageToXItems?: InputMaybe<Scalars['Int']['input']>;\n  /** Maximum order amount allowed when using the coupon. */\n  maximumAmount?: InputMaybe<Scalars['String']['input']>;\n  /** Meta data. */\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n  /** Minimum order amount that needs to be in the cart before coupon applies. */\n  minimumAmount?: InputMaybe<Scalars['String']['input']>;\n  /** List of category IDs the coupon applies to. */\n  productCategories?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** List of product IDs the coupon can be used on. */\n  productIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** How many times the coupon can be used in total. */\n  usageLimit?: InputMaybe<Scalars['Int']['input']>;\n  /** How many times the coupon can be used per customer. */\n  usageLimitPerUser?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Input for the updateCustomer mutation. */\nexport type UpdateCustomerInput = {\n  /** User's AOL IM account. */\n  aim?: InputMaybe<Scalars['String']['input']>;\n  /** Customer billing information */\n  billing?: InputMaybe<CustomerAddressInput>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing content about the user. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user). */\n  displayName?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing the user's email address. */\n  email?: InputMaybe<Scalars['String']['input']>;\n  /** \tThe user's first name. */\n  firstName?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the user */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** User's Jabber account. */\n  jabber?: InputMaybe<Scalars['String']['input']>;\n  /** The user's last name. */\n  lastName?: InputMaybe<Scalars['String']['input']>;\n  /** User's locale. */\n  locale?: InputMaybe<Scalars['String']['input']>;\n  /** Meta data. */\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n  /** A string that contains a URL-friendly name for the user. The default is the user's username. */\n  nicename?: InputMaybe<Scalars['String']['input']>;\n  /** The user's nickname, defaults to the user's username. */\n  nickname?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains the plain text password for the user. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** The date the user registered. Format is Y-m-d H:i:s. */\n  registered?: InputMaybe<Scalars['String']['input']>;\n  /** A string for whether to enable the rich editor or not. False if not empty. */\n  richEditing?: InputMaybe<Scalars['String']['input']>;\n  /** An array of roles to be assigned to the user. */\n  roles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Customer shipping address */\n  shipping?: InputMaybe<CustomerAddressInput>;\n  /** Customer shipping is identical to billing address */\n  shippingSameAsBilling?: InputMaybe<Scalars['Boolean']['input']>;\n  /** A string containing the user's URL for the user's web site. */\n  websiteUrl?: InputMaybe<Scalars['String']['input']>;\n  /** User's Yahoo IM account. */\n  yim?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateItemQuantities mutation. */\nexport type UpdateItemQuantitiesInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Cart item being updated */\n  items?: InputMaybe<Array<InputMaybe<CartItemQuantityInput>>>;\n};\n\n/** Input for the updateMediaItem mutation. */\nexport type UpdateMediaItemInput = {\n  /** Alternative text to display when mediaItem is not displayed */\n  altText?: InputMaybe<Scalars['String']['input']>;\n  /** The userId to assign as the author of the mediaItem */\n  authorId?: InputMaybe<Scalars['ID']['input']>;\n  /** The caption for the mediaItem */\n  caption?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The comment status for the mediaItem */\n  commentStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the mediaItem */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** The date (in GMT zone) of the mediaItem */\n  dateGmt?: InputMaybe<Scalars['String']['input']>;\n  /** Description of the mediaItem */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The file name of the mediaItem */\n  filePath?: InputMaybe<Scalars['String']['input']>;\n  /** The file type of the mediaItem */\n  fileType?: InputMaybe<MimeTypeEnum>;\n  /** The ID of the mediaItem object */\n  id: Scalars['ID']['input'];\n  /** The ID of the parent object */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n  /** The ping status for the mediaItem */\n  pingStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the mediaItem */\n  slug?: InputMaybe<Scalars['String']['input']>;\n  /** The status of the mediaItem */\n  status?: InputMaybe<MediaItemStatusEnum>;\n  /** The title of the mediaItem */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateMethodOnShippingZone mutation. */\nexport type UpdateMethodOnShippingZoneInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the shipping method is enabled or not. */\n  enabled?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Shipping method instance ID */\n  instanceId: Scalars['Int']['input'];\n  /** The order of the shipping method. */\n  order?: InputMaybe<Scalars['Int']['input']>;\n  /** The settings for the shipping method. */\n  settings?: InputMaybe<Array<InputMaybe<WcSettingInput>>>;\n  /** The ID of the shipping zone to delete. */\n  zoneId: Scalars['Int']['input'];\n};\n\n/** Input for the updateOrder mutation. */\nexport type UpdateOrderInput = {\n  /** Order billing address */\n  billing?: InputMaybe<CustomerAddressInput>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Coupons codes to be applied to order */\n  coupons?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Currency the order was created with, in ISO format. */\n  currency?: InputMaybe<CurrencyEnum>;\n  /** Order customer ID */\n  customerId?: InputMaybe<Scalars['Int']['input']>;\n  /** Note left by customer during checkout. */\n  customerNote?: InputMaybe<Scalars['String']['input']>;\n  /** Order shipping lines */\n  feeLines?: InputMaybe<Array<InputMaybe<FeeLineInput>>>;\n  /** Order global ID */\n  id?: InputMaybe<Scalars['ID']['input']>;\n  /** Define if the order is paid. It will set the status to processing and reduce stock items. */\n  isPaid?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Order line items */\n  lineItems?: InputMaybe<Array<InputMaybe<LineItemInput>>>;\n  /** Order meta data */\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n  /** Order WP ID */\n  orderId?: InputMaybe<Scalars['Int']['input']>;\n  /** Parent order ID. */\n  parentId?: InputMaybe<Scalars['Int']['input']>;\n  /** Payment method ID. */\n  paymentMethod?: InputMaybe<Scalars['String']['input']>;\n  /** Payment method title. */\n  paymentMethodTitle?: InputMaybe<Scalars['String']['input']>;\n  /** Order shipping address */\n  shipping?: InputMaybe<CustomerAddressInput>;\n  /** Order shipping lines */\n  shippingLines?: InputMaybe<Array<InputMaybe<ShippingLineInput>>>;\n  /** Order status */\n  status?: InputMaybe<OrderStatusEnum>;\n  /** Order transaction ID */\n  transactionId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updatePage mutation. */\nexport type UpdatePageInput = {\n  /** The userId to assign as the author of the object */\n  authorId?: InputMaybe<Scalars['ID']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The comment status for the object */\n  commentStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The content of the object */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the page object */\n  id: Scalars['ID']['input'];\n  /** Override the edit lock when another user is editing the post */\n  ignoreEditLock?: InputMaybe<Scalars['Boolean']['input']>;\n  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */\n  menuOrder?: InputMaybe<Scalars['Int']['input']>;\n  /** The ID of the parent object */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n  /** The password used to protect the content of the object */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** The slug of the object */\n  slug?: InputMaybe<Scalars['String']['input']>;\n  /** The status of the object */\n  status?: InputMaybe<PostStatusEnum>;\n  /** The title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updatePostFormat mutation. */\nexport type UpdatePostFormatInput = {\n  /** The slug that the post_format will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the post_format object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the postFormat object to update */\n  id: Scalars['ID']['input'];\n  /** The name of the post_format object to mutate */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updatePost mutation. */\nexport type UpdatePostInput = {\n  /** The userId to assign as the author of the object */\n  authorId?: InputMaybe<Scalars['ID']['input']>;\n  /** Set connections between the post and categories */\n  categories?: InputMaybe<PostCategoriesInput>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The comment status for the object */\n  commentStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The content of the object */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** The excerpt of the object */\n  excerpt?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the post object */\n  id: Scalars['ID']['input'];\n  /** Override the edit lock when another user is editing the post */\n  ignoreEditLock?: InputMaybe<Scalars['Boolean']['input']>;\n  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */\n  menuOrder?: InputMaybe<Scalars['Int']['input']>;\n  /** The password used to protect the content of the object */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** The ping status for the object */\n  pingStatus?: InputMaybe<Scalars['String']['input']>;\n  /** URLs that have been pinged. */\n  pinged?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Set connections between the post and postFormats */\n  postFormats?: InputMaybe<PostPostFormatsInput>;\n  /** The slug of the object */\n  slug?: InputMaybe<Scalars['String']['input']>;\n  /** The status of the object */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Set connections between the post and tags */\n  tags?: InputMaybe<PostTagsInput>;\n  /** The title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n  /** URLs queued to be pinged. */\n  toPing?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Input for the updateProductCategory mutation. */\nexport type UpdateProductCategoryInput = {\n  /** The slug that the product_cat will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_cat object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the productCategory object to update */\n  id: Scalars['ID']['input'];\n  /** The name of the product_cat object to mutate */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the product_cat that should be set as the parent */\n  parentId?: InputMaybe<Scalars['ID']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateProduct mutation. */\nexport type UpdateProductInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The comment status for the object */\n  commentStatus?: InputMaybe<Scalars['String']['input']>;\n  /** The content of the object */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** The excerpt of the object */\n  excerpt?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the Product object */\n  id: Scalars['ID']['input'];\n  /** Override the edit lock when another user is editing the post */\n  ignoreEditLock?: InputMaybe<Scalars['Boolean']['input']>;\n  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */\n  menuOrder?: InputMaybe<Scalars['Int']['input']>;\n  /** The password used to protect the content of the object */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Set connections between the Product and productCategories */\n  productCategories?: InputMaybe<ProductProductCategoriesInput>;\n  /** Set connections between the Product and productTags */\n  productTags?: InputMaybe<ProductProductTagsInput>;\n  /** Set connections between the Product and productTypes */\n  productTypes?: InputMaybe<ProductProductTypesInput>;\n  /** Set connections between the Product and shippingClasses */\n  shippingClasses?: InputMaybe<ProductShippingClassesInput>;\n  /** The slug of the object */\n  slug?: InputMaybe<Scalars['String']['input']>;\n  /** The status of the object */\n  status?: InputMaybe<PostStatusEnum>;\n  /** The title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n  /** Set connections between the Product and visibleProducts */\n  visibleProducts?: InputMaybe<ProductVisibleProductsInput>;\n};\n\n/** Input for the updateProductTag mutation. */\nexport type UpdateProductTagInput = {\n  /** The slug that the product_tag will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_tag object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the productTag object to update */\n  id: Scalars['ID']['input'];\n  /** The name of the product_tag object to mutate */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateProductType mutation. */\nexport type UpdateProductTypeInput = {\n  /** The slug that the product_type will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_type object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the productType object to update */\n  id: Scalars['ID']['input'];\n  /** The name of the product_type object to mutate */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateReview mutation. */\nexport type UpdateReviewInput = {\n  /** The approval status of the comment. */\n  approved?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the comment's author. */\n  author?: InputMaybe<Scalars['String']['input']>;\n  /** The email of the comment's author. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** The url of the comment's author. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The database ID of the post object the comment belongs to. */\n  commentOn?: InputMaybe<Scalars['Int']['input']>;\n  /** Content of the comment. */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the review being updated. */\n  id: Scalars['ID']['input'];\n  /** Parent comment ID of current comment. */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Product rating */\n  rating: Scalars['Int']['input'];\n  /** The approval status of the comment */\n  status?: InputMaybe<CommentStatusEnum>;\n};\n\n/** Input for the updateSession mutation. */\nexport type UpdateSessionInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Data to be persisted in the session. */\n  sessionData?: InputMaybe<Array<InputMaybe<MetaDataInput>>>;\n};\n\n/** Input for the updateSettings mutation. */\nexport type UpdateSettingsInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Allow people to submit comments on new posts. */\n  discussionSettingsDefaultCommentStatus?: InputMaybe<Scalars['String']['input']>;\n  /** Allow link notifications from other blogs (pingbacks and trackbacks) on new articles. */\n  discussionSettingsDefaultPingStatus?: InputMaybe<Scalars['String']['input']>;\n  /** A date format for all date strings. */\n  generalSettingsDateFormat?: InputMaybe<Scalars['String']['input']>;\n  /** Site tagline. */\n  generalSettingsDescription?: InputMaybe<Scalars['String']['input']>;\n  /** This address is used for admin purposes, like new user notification. */\n  generalSettingsEmail?: InputMaybe<Scalars['String']['input']>;\n  /** WordPress locale code. */\n  generalSettingsLanguage?: InputMaybe<Scalars['String']['input']>;\n  /** A day number of the week that the week should start on. */\n  generalSettingsStartOfWeek?: InputMaybe<Scalars['Int']['input']>;\n  /** A time format for all time strings. */\n  generalSettingsTimeFormat?: InputMaybe<Scalars['String']['input']>;\n  /** A city in the same timezone as you. */\n  generalSettingsTimezone?: InputMaybe<Scalars['String']['input']>;\n  /** Site title. */\n  generalSettingsTitle?: InputMaybe<Scalars['String']['input']>;\n  /** Site URL. */\n  generalSettingsUrl?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the page that should display the latest posts */\n  readingSettingsPageForPosts?: InputMaybe<Scalars['Int']['input']>;\n  /** The ID of the page that should be displayed on the front page */\n  readingSettingsPageOnFront?: InputMaybe<Scalars['Int']['input']>;\n  /** Blog pages show at most. */\n  readingSettingsPostsPerPage?: InputMaybe<Scalars['Int']['input']>;\n  /** What to show on the front page */\n  readingSettingsShowOnFront?: InputMaybe<Scalars['String']['input']>;\n  /** Default post category. */\n  writingSettingsDefaultCategory?: InputMaybe<Scalars['Int']['input']>;\n  /** Default post format. */\n  writingSettingsDefaultPostFormat?: InputMaybe<Scalars['String']['input']>;\n  /** Convert emoticons like :-) and :-P to graphics on display. */\n  writingSettingsUseSmilies?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** Input for the updateShippingClass mutation. */\nexport type UpdateShippingClassInput = {\n  /** The slug that the product_shipping_class will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_shipping_class object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the shippingClass object to update */\n  id: Scalars['ID']['input'];\n  /** The name of the product_shipping_class object to mutate */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateShippingMethod mutation. */\nexport type UpdateShippingMethodInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  shippingMethods?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n};\n\n/** Input for the updateShippingZone mutation. */\nexport type UpdateShippingZoneInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the shipping zone to update. */\n  id: Scalars['Int']['input'];\n  /** Name of the shipping zone. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Order of the shipping zone. */\n  order?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Input for the updateShippingZoneLocations mutation. */\nexport type UpdateShippingZoneLocationsInput = {\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The locations to add to the shipping zone. */\n  locations?: InputMaybe<Array<InputMaybe<ShippingLocationInput>>>;\n  /** The ID of the shipping zone to delete. */\n  zoneId: Scalars['Int']['input'];\n};\n\n/** Input for the updateTag mutation. */\nexport type UpdateTagInput = {\n  /** The slug that the post_tag will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the post_tag object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the tag object to update */\n  id: Scalars['ID']['input'];\n  /** The name of the post_tag object to mutate */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateTaxRate mutation. */\nexport type UpdateTaxRateInput = {\n  /** Cities for the tax rate. */\n  cities?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Tax rate class. */\n  class?: InputMaybe<TaxClassEnum>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the tax rate is compound. */\n  compound?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Country code for the tax rate. */\n  country?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the tax rate to update. */\n  id: Scalars['Int']['input'];\n  /** Tax rate name. */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Tax rate order. */\n  order?: InputMaybe<Scalars['Int']['input']>;\n  /** Postcodes for the tax rate. */\n  postcodes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Tax rate priority. */\n  priority?: InputMaybe<Scalars['Int']['input']>;\n  /** Tax rate. */\n  rate?: InputMaybe<Scalars['String']['input']>;\n  /** Whether the tax rate is applied to shipping. */\n  shipping?: InputMaybe<Scalars['Boolean']['input']>;\n  /** State code for the tax rate. */\n  state?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateUser mutation. */\nexport type UpdateUserInput = {\n  /** User's AOL IM account. */\n  aim?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing content about the user. */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user). */\n  displayName?: InputMaybe<Scalars['String']['input']>;\n  /** A string containing the user's email address. */\n  email?: InputMaybe<Scalars['String']['input']>;\n  /** \tThe user's first name. */\n  firstName?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the user */\n  id: Scalars['ID']['input'];\n  /** User's Jabber account. */\n  jabber?: InputMaybe<Scalars['String']['input']>;\n  /** The user's last name. */\n  lastName?: InputMaybe<Scalars['String']['input']>;\n  /** User's locale. */\n  locale?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains a URL-friendly name for the user. The default is the user's username. */\n  nicename?: InputMaybe<Scalars['String']['input']>;\n  /** The user's nickname, defaults to the user's username. */\n  nickname?: InputMaybe<Scalars['String']['input']>;\n  /** A string that contains the plain text password for the user. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** The date the user registered. Format is Y-m-d H:i:s. */\n  registered?: InputMaybe<Scalars['String']['input']>;\n  /** A string for whether to enable the rich editor or not. False if not empty. */\n  richEditing?: InputMaybe<Scalars['String']['input']>;\n  /** An array of roles to be assigned to the user. */\n  roles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** A string containing the user's URL for the user's web site. */\n  websiteUrl?: InputMaybe<Scalars['String']['input']>;\n  /** User's Yahoo IM account. */\n  yim?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Input for the updateVisibleProduct mutation. */\nexport type UpdateVisibleProductInput = {\n  /** The slug that the product_visibility will be an alias of */\n  aliasOf?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The description of the product_visibility object */\n  description?: InputMaybe<Scalars['String']['input']>;\n  /** The ID of the visibleProduct object to update */\n  id: Scalars['ID']['input'];\n  /** The name of the product_visibility object to mutate */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */\n  slug?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** The Type of Identifier used to fetch a single User node. To be used along with the \"id\" field. Default is \"ID\". */\nexport enum UserNodeIdTypeEnum {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The Email of the User */\n  EMAIL = 'EMAIL',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The slug of the User */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI',\n  /** The username the User uses to login with */\n  USERNAME = 'USERNAME'\n}\n\n/** Names of available user roles */\nexport enum UserRoleEnum {\n  /** User role with specific capabilities */\n  ADMINISTRATOR = 'ADMINISTRATOR',\n  /** User role with specific capabilities */\n  AUTHOR = 'AUTHOR',\n  /** User role with specific capabilities */\n  CONTRIBUTOR = 'CONTRIBUTOR',\n  /** User role with specific capabilities */\n  CUSTOMER = 'CUSTOMER',\n  /** User role with specific capabilities */\n  EDITOR = 'EDITOR',\n  /** User role with specific capabilities */\n  SHOP_MANAGER = 'SHOP_MANAGER',\n  /** User role with specific capabilities */\n  SUBSCRIBER = 'SUBSCRIBER'\n}\n\n/** Arguments for filtering the UserToCommentConnection connection */\nexport type UserToCommentConnectionWhereArgs = {\n  /** Comment author email address. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** Array of author IDs to include comments for. */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to exclude comments for. */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Comment author URL. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** Array of comment IDs to include. */\n  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */\n  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Include comments of a given type. */\n  commentType?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments from a given array of comment types. */\n  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Exclude comments from a given array of comment types. */\n  commentTypeNotIn?: InputMaybe<Scalars['String']['input']>;\n  /** Content object author ID to limit results by. */\n  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs to retrieve comments for. */\n  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of author IDs *not* to retrieve comments for. */\n  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Limit results to those affiliated with a given content object ID. */\n  contentId?: InputMaybe<Scalars['ID']['input']>;\n  /** Array of content object IDs to include affiliated comments for. */\n  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of content object IDs to exclude affiliated comments for. */\n  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Content object name (i.e. slug ) to retrieve affiliated comments for. */\n  contentName?: InputMaybe<Scalars['String']['input']>;\n  /** Content Object parent ID to retrieve affiliated comments for. */\n  contentParent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */\n  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */\n  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Karma score to retrieve matching comments for. */\n  karma?: InputMaybe<Scalars['Int']['input']>;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n  /** Field to order the comments by. */\n  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;\n  /** Parent ID of comment to retrieve children of. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of parent IDs of comments to retrieve children for. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of parent IDs of comments *not* to retrieve children for. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Search term(s) to retrieve matching comments for. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Comment status to limit results by. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Include comments for a specific user ID. */\n  userId?: InputMaybe<Scalars['ID']['input']>;\n};\n\n/** Arguments for filtering the UserToMediaItemConnection connection */\nexport type UserToMediaItemConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the UserToPageConnection connection */\nexport type UserToPageConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the UserToPostConnection connection */\nexport type UserToPostConnectionWhereArgs = {\n  /** The user that's connected as the author of the object. Use the userId for the author object. */\n  author?: InputMaybe<Scalars['Int']['input']>;\n  /** Find objects connected to author(s) in the array of author's userIds */\n  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Find objects connected to the author by the author's nicename */\n  authorName?: InputMaybe<Scalars['String']['input']>;\n  /** Find objects NOT connected to author(s) in the array of author's userIds */\n  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Category ID */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Use Category Slug */\n  categoryName?: InputMaybe<Scalars['String']['input']>;\n  /** Array of category IDs, used to display objects from one category OR another */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Tag Slug */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Use Tag ID */\n  tagId?: InputMaybe<Scalars['String']['input']>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag IDs, used to display objects from one tag OR another */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Array of tag slugs, used to display objects from one tag AND another */\n  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Array of tag slugs, used to include objects in ANY specified tags */\n  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the UserToRevisionsConnection connection */\nexport type UserToRevisionsConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Field to order the connection by */\nexport enum UsersConnectionOrderbyEnum {\n  /** Order by display name */\n  DISPLAY_NAME = 'DISPLAY_NAME',\n  /** Order by email address */\n  EMAIL = 'EMAIL',\n  /** Order by login */\n  LOGIN = 'LOGIN',\n  /** Preserve the login order given in the LOGIN_IN array */\n  LOGIN_IN = 'LOGIN_IN',\n  /** Order by nice name */\n  NICE_NAME = 'NICE_NAME',\n  /** Preserve the nice name order given in the NICE_NAME_IN array */\n  NICE_NAME_IN = 'NICE_NAME_IN',\n  /** Order by registration date */\n  REGISTERED = 'REGISTERED',\n  /** Order by URL */\n  URL = 'URL'\n}\n\n/** Options for ordering the connection */\nexport type UsersConnectionOrderbyInput = {\n  /** The field name used to sort the results. */\n  field: UsersConnectionOrderbyEnum;\n  /** The cardinality of the order of the connection */\n  order?: InputMaybe<OrderEnum>;\n};\n\n/** Column used for searching for users. */\nexport enum UsersConnectionSearchColumnEnum {\n  /** The user's email address. */\n  EMAIL = 'EMAIL',\n  /** The globally unique ID. */\n  ID = 'ID',\n  /** The username the User uses to login with. */\n  LOGIN = 'LOGIN',\n  /** A URL-friendly name for the user. The default is the user's username. */\n  NICENAME = 'NICENAME',\n  /** The URL of the user's website. */\n  URL = 'URL'\n}\n\n/** Arguments for filtering the VariableProductToProductUnionConnection connection */\nexport type VariableProductToProductUnionConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** The Type of Identifier used to fetch a single resource. Default is ID. */\nexport enum VisibleProductIdType {\n  /** The Database ID for the node */\n  DATABASE_ID = 'DATABASE_ID',\n  /** The hashed Global ID */\n  ID = 'ID',\n  /** The name of the node */\n  NAME = 'NAME',\n  /** Url friendly name of the node */\n  SLUG = 'SLUG',\n  /** The URI for the node */\n  URI = 'URI'\n}\n\n/** Arguments for filtering the VisibleProductToContentNodeConnection connection */\nexport type VisibleProductToContentNodeConnectionWhereArgs = {\n  /** The Types of content to filter */\n  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfVisibleProductEnum>>>;\n  /** Filter the connection based on dates */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */\n  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Specific database ID of the object */\n  id?: InputMaybe<Scalars['Int']['input']>;\n  /** Array of IDs for the objects to retrieve */\n  in?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Get objects with a specific mimeType property */\n  mimeType?: InputMaybe<MimeTypeEnum>;\n  /** Slug / post_name of the object */\n  name?: InputMaybe<Scalars['String']['input']>;\n  /** Specify objects to retrieve. Use slugs */\n  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored */\n  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** What parameter to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Specify objects whose parent is in an array */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Specify posts whose parent is not in an array */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;\n  /** Show posts with a specific password. */\n  password?: InputMaybe<Scalars['String']['input']>;\n  /** Show Posts based on a keyword search */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Retrieve posts where post status is in an array. */\n  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;\n  /** Show posts with a specific status. */\n  status?: InputMaybe<PostStatusEnum>;\n  /** Title of the object */\n  title?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Arguments for filtering the VisibleProductToProductConnection connection */\nexport type VisibleProductToProductConnectionWhereArgs = {\n  /** Limit result set to products with a specific global product attribute */\n  attribute?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with a specific global product attribute term ID (required an assigned attribute). */\n  attributeTerm?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with selected global attribute queries. */\n  attributes?: InputMaybe<ProductAttributeQueryInput>;\n  /** Limit result set to products assigned a specific category name. */\n  category?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific category name. */\n  categoryId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of category IDs. */\n  categoryIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of category IDs. */\n  categoryIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a group of specific categories by name. */\n  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a group of specific categories by name. */\n  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Filter the connection based on dates. */\n  dateQuery?: InputMaybe<DateQueryInput>;\n  /** Ensure result set excludes specific IDs. */\n  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to featured products. */\n  featured?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to specific ids. */\n  include?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Include variations in the result set. */\n  includeVariations?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products based on a maximum price. */\n  maxPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products based on a minimum price. */\n  minPrice?: InputMaybe<Scalars['Float']['input']>;\n  /** Limit result set to products on sale. */\n  onSale?: InputMaybe<Scalars['Boolean']['input']>;\n  /** What paramater to use to order the objects by. */\n  orderby?: InputMaybe<Array<InputMaybe<ProductsOrderbyInput>>>;\n  /** Use ID to return only children. Use 0 to return only top-level items. */\n  parent?: InputMaybe<Scalars['Int']['input']>;\n  /** Specify objects whose parent is in an array. */\n  parentIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Specify objects whose parent is not in an array. */\n  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products with a specific average rating. Must be between 1 and 5 */\n  rating?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products based on a keyword search. */\n  search?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific shipping class ID. */\n  shippingClassId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products with specific SKU(s). Use commas to separate. */\n  sku?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products with specific slugs. */\n  slugIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products assigned a specific status. */\n  status?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products in stock or out of stock. */\n  stockStatus?: InputMaybe<Array<InputMaybe<StockStatusEnum>>>;\n  /** Limit result types to types supported by WooGraphQL. */\n  supportedTypesOnly?: InputMaybe<Scalars['Boolean']['input']>;\n  /** Limit result set to products assigned a specific tag name. */\n  tag?: InputMaybe<Scalars['String']['input']>;\n  /** Limit result set to products assigned a specific tag ID. */\n  tagId?: InputMaybe<Scalars['Int']['input']>;\n  /** Limit result set to products assigned to a specific group of tag IDs. */\n  tagIdIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tag IDs. */\n  tagIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;\n  /** Limit result set to products assigned to a specific group of tags by name. */\n  tagIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set to products not assigned to a specific group of tags by name. */\n  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;\n  /** Limit result set with complex set of taxonomy filters. */\n  taxonomyFilter?: InputMaybe<ProductTaxonomyInput>;\n  /** Limit result set to products assigned a specific type. */\n  type?: InputMaybe<ProductTypesEnum>;\n  /** Limit result set to products assigned to a group of specific types. */\n  typeIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products not assigned to a group of specific types. */\n  typeNotIn?: InputMaybe<Array<InputMaybe<ProductTypesEnum>>>;\n  /** Limit result set to products with a specific visibility level. */\n  visibility?: InputMaybe<CatalogVisibilityEnum>;\n};\n\n/** WooCommerce setting input. */\nexport type WcSettingInput = {\n  /** A unique identifier for the setting. */\n  id?: InputMaybe<Scalars['String']['input']>;\n  /** Setting value. */\n  value?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Type of WC setting. */\nexport enum WcSettingTypeEnum {\n  CHECKBOX = 'CHECKBOX',\n  COLOR = 'COLOR',\n  EMAIL = 'EMAIL',\n  IMAGE_WIDTH = 'IMAGE_WIDTH',\n  MULTI_SELECT = 'MULTI_SELECT',\n  NUMBER = 'NUMBER',\n  PASSWORD = 'PASSWORD',\n  RADIO = 'RADIO',\n  SELECT = 'SELECT',\n  TEXT = 'TEXT',\n  TEXTAREA = 'TEXTAREA'\n}\n\n/** Input for the writeReview mutation. */\nexport type WriteReviewInput = {\n  /** The approval status of the comment. */\n  approved?: InputMaybe<Scalars['String']['input']>;\n  /** The name of the comment's author. */\n  author?: InputMaybe<Scalars['String']['input']>;\n  /** The email of the comment's author. */\n  authorEmail?: InputMaybe<Scalars['String']['input']>;\n  /** The url of the comment's author. */\n  authorUrl?: InputMaybe<Scalars['String']['input']>;\n  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */\n  clientMutationId?: InputMaybe<Scalars['String']['input']>;\n  /** The database ID of the post object the comment belongs to. */\n  commentOn?: InputMaybe<Scalars['Int']['input']>;\n  /** Content of the comment. */\n  content?: InputMaybe<Scalars['String']['input']>;\n  /** The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17  */\n  date?: InputMaybe<Scalars['String']['input']>;\n  /** Parent comment ID of current comment. */\n  parent?: InputMaybe<Scalars['ID']['input']>;\n  /** Product rating */\n  rating: Scalars['Int']['input'];\n  /** The approval status of the comment */\n  status?: InputMaybe<CommentStatusEnum>;\n};\n\nexport type AddToCartMutationVariables = Exact<{\n  input: AddToCartInput;\n}>;\n\n\nexport type AddToCartMutation = { addToCart?: { cart?: { total?: string | null, subtotal?: string | null, totalTax?: string | null, discountTotal?: string | null, shippingTotal?: string | null, chosenShippingMethods?: Array<string | null> | null, isEmpty?: boolean | null, rawTotal?: string | null, rawDiscountTotal?: string | null, availableShippingMethods?: Array<{ rates?: Array<{ cost?: string | null, id: string, label?: string | null } | null> | null } | null> | null, appliedCoupons?: Array<{ description?: string | null, discountTax: string, discountAmount: string, code: string } | null> | null, contents?: { itemCount?: number | null, productCount?: number | null, nodes: Array<{ quantity?: number | null, key: string, product?: { node: { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } } | null, variation?: { node: { name?: string | null, slug?: string | null, price?: string | null, stockStatus?: StockStatusEnum | null, regularPrice?: string | null, salePrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, cartSourceUrl?: string | null } | null } } | null }> } | null } | null } | null };\n\nexport type ApplyCouponMutationVariables = Exact<{\n  code: Scalars['String']['input'];\n}>;\n\n\nexport type ApplyCouponMutation = { applyCoupon?: { applied?: { code: string, description?: string | null, discountTax: string, discountAmount: string } | null, cart?: { total?: string | null, subtotal?: string | null, totalTax?: string | null, discountTotal?: string | null, shippingTotal?: string | null, chosenShippingMethods?: Array<string | null> | null, isEmpty?: boolean | null, rawTotal?: string | null, rawDiscountTotal?: string | null, availableShippingMethods?: Array<{ rates?: Array<{ cost?: string | null, id: string, label?: string | null } | null> | null } | null> | null, appliedCoupons?: Array<{ description?: string | null, discountTax: string, discountAmount: string, code: string } | null> | null, contents?: { itemCount?: number | null, productCount?: number | null, nodes: Array<{ quantity?: number | null, key: string, product?: { node: { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } } | null, variation?: { node: { name?: string | null, slug?: string | null, price?: string | null, stockStatus?: StockStatusEnum | null, regularPrice?: string | null, salePrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, cartSourceUrl?: string | null } | null } } | null }> } | null } | null } | null };\n\nexport type ChangeShippingCountyMutationVariables = Exact<{\n  shippingState: Scalars['String']['input'];\n  shippingCountry: CountriesEnum;\n  billingState: Scalars['String']['input'];\n  billingCountry: CountriesEnum;\n}>;\n\n\nexport type ChangeShippingCountyMutation = { updateCustomer?: { customer?: { calculatedShipping?: boolean | null, hasCalculatedShipping?: boolean | null } | null } | null };\n\nexport type ChangeShippingMethodMutationVariables = Exact<{\n  shippingMethods?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;\n}>;\n\n\nexport type ChangeShippingMethodMutation = { updateShippingMethod?: { cart?: { total?: string | null, subtotal?: string | null, totalTax?: string | null, discountTotal?: string | null, shippingTotal?: string | null, chosenShippingMethods?: Array<string | null> | null, isEmpty?: boolean | null, rawTotal?: string | null, rawDiscountTotal?: string | null, availableShippingMethods?: Array<{ rates?: Array<{ cost?: string | null, id: string, label?: string | null } | null> | null } | null> | null, appliedCoupons?: Array<{ description?: string | null, discountTax: string, discountAmount: string, code: string } | null> | null, contents?: { itemCount?: number | null, productCount?: number | null, nodes: Array<{ quantity?: number | null, key: string, product?: { node: { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } } | null, variation?: { node: { name?: string | null, slug?: string | null, price?: string | null, stockStatus?: StockStatusEnum | null, regularPrice?: string | null, salePrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, cartSourceUrl?: string | null } | null } } | null }> } | null } | null } | null };\n\nexport type CheckoutMutationVariables = Exact<{\n  billing?: InputMaybe<CustomerAddressInput>;\n  metaData?: InputMaybe<Array<InputMaybe<MetaDataInput>> | InputMaybe<MetaDataInput>>;\n  paymentMethod?: InputMaybe<Scalars['String']['input']>;\n  shipping?: InputMaybe<CustomerAddressInput>;\n  customerNote?: InputMaybe<Scalars['String']['input']>;\n  shipToDifferentAddress?: InputMaybe<Scalars['Boolean']['input']>;\n  account?: InputMaybe<CreateAccountInput>;\n  transactionId?: InputMaybe<Scalars['String']['input']>;\n  isPaid?: InputMaybe<Scalars['Boolean']['input']>;\n}>;\n\n\nexport type CheckoutMutation = { checkout?: { result?: string | null, redirect?: string | null, order?: { needsPayment?: boolean | null, needsProcessing?: boolean | null, status?: OrderStatusEnum | null, databaseId?: number | null, orderKey?: string | null, subtotal?: string | null, total?: string | null, totalTax?: string | null, shippingTotal?: string | null, paymentMethodTitle?: string | null, paymentMethod?: string | null, date?: string | null, customer?: { email?: string | null } | null, lineItems?: { nodes: Array<{ quantity?: number | null, total?: string | null, product?: { node: { name?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number } | null } | { name?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number } | null } | { name?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number } | null } | { name?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number } | null } } | null, variation?: { node: { name?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number } | null } } | null }> } | null } | null } | null };\n\nexport type EmptyCartMutationVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type EmptyCartMutation = { emptyCart?: { cart?: { total?: string | null, subtotal?: string | null, totalTax?: string | null, discountTotal?: string | null, shippingTotal?: string | null, chosenShippingMethods?: Array<string | null> | null, isEmpty?: boolean | null, rawTotal?: string | null, rawDiscountTotal?: string | null, availableShippingMethods?: Array<{ rates?: Array<{ cost?: string | null, id: string, label?: string | null } | null> | null } | null> | null, appliedCoupons?: Array<{ description?: string | null, discountTax: string, discountAmount: string, code: string } | null> | null, contents?: { itemCount?: number | null, productCount?: number | null, nodes: Array<{ quantity?: number | null, key: string, product?: { node: { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } } | null, variation?: { node: { name?: string | null, slug?: string | null, price?: string | null, stockStatus?: StockStatusEnum | null, regularPrice?: string | null, salePrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, cartSourceUrl?: string | null } | null } } | null }> } | null } | null } | null };\n\nexport type CartFragment = { total?: string | null, subtotal?: string | null, totalTax?: string | null, discountTotal?: string | null, shippingTotal?: string | null, chosenShippingMethods?: Array<string | null> | null, isEmpty?: boolean | null, rawTotal?: string | null, rawDiscountTotal?: string | null, availableShippingMethods?: Array<{ rates?: Array<{ cost?: string | null, id: string, label?: string | null } | null> | null } | null> | null, appliedCoupons?: Array<{ description?: string | null, discountTax: string, discountAmount: string, code: string } | null> | null, contents?: { itemCount?: number | null, productCount?: number | null, nodes: Array<{ quantity?: number | null, key: string, product?: { node: { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } } | null, variation?: { node: { name?: string | null, slug?: string | null, price?: string | null, stockStatus?: StockStatusEnum | null, regularPrice?: string | null, salePrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, cartSourceUrl?: string | null } | null } } | null }> } | null };\n\nexport type CustomerFragment = { lastName?: string | null, email?: string | null, firstName?: string | null, username?: string | null, databaseId?: number | null, sessionToken?: string | null, isPayingCustomer?: boolean | null, billing?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null, shipping?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null };\n\nexport type AddressFragment = { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null };\n\nexport type DownloadableItemFragment = { id: string, name?: string | null, url?: string | null, accessExpires?: string | null, downloadsRemaining?: number | null, product?: { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | null };\n\nexport type ExternalProductFragment = { externalUrl?: string | null, buttonText?: string | null };\n\nexport type ImageFragment = { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number };\n\nexport type OrderFragmentFragment = { orderNumber?: string | null, date?: string | null, status?: OrderStatusEnum | null, needsPayment?: boolean | null, needsProcessing?: boolean | null, databaseId?: number | null, orderKey?: string | null, total?: string | null, subtotal?: string | null, discountTotal?: string | null, totalTax?: string | null, shippingTotal?: string | null, paymentMethodTitle?: string | null, paymentMethod?: string | null, rawDiscountTotal?: string | null, customer?: { email?: string | null, lastName?: string | null, firstName?: string | null, username?: string | null, databaseId?: number | null, sessionToken?: string | null, isPayingCustomer?: boolean | null, downloadableItems?: { nodes: Array<{ id: string, name?: string | null, url?: string | null, accessExpires?: string | null, downloadsRemaining?: number | null, product?: { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | null }> } | null, billing?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null, shipping?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null } | null, downloadableItems?: { nodes: Array<{ id: string, name?: string | null, url?: string | null, accessExpires?: string | null, downloadsRemaining?: number | null, product?: { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | null }> } | null, lineItems?: { nodes: Array<{ quantity?: number | null, total?: string | null, id: string, product?: { node: { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } | { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } | { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } | { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } } | null, variation?: { node: { name?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } } | null }> } | null };\n\ntype ProductCategories_ExternalProduct_Fragment = { productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null };\n\ntype ProductCategories_GroupProduct_Fragment = { productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null };\n\ntype ProductCategories_SimpleProduct_Fragment = { productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null };\n\ntype ProductCategories_VariableProduct_Fragment = { productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null };\n\nexport type ProductCategoriesFragment = ProductCategories_ExternalProduct_Fragment | ProductCategories_GroupProduct_Fragment | ProductCategories_SimpleProduct_Fragment | ProductCategories_VariableProduct_Fragment;\n\nexport type SimpleProductFragment = { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null };\n\ntype Terms_ExternalProduct_Fragment = { terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null };\n\ntype Terms_GroupProduct_Fragment = { terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null };\n\ntype Terms_SimpleProduct_Fragment = { terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null };\n\ntype Terms_VariableProduct_Fragment = { terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null };\n\nexport type TermsFragment = Terms_ExternalProduct_Fragment | Terms_GroupProduct_Fragment | Terms_SimpleProduct_Fragment | Terms_VariableProduct_Fragment;\n\nexport type VariableProductFragment = { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null };\n\nexport type VariationAttributeFragment = { name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null };\n\nexport type GetAllTermsQueryVariables = Exact<{\n  hideEmpty?: InputMaybe<Scalars['Boolean']['input']>;\n  taxonomies: Array<InputMaybe<TaxonomyEnum>> | InputMaybe<TaxonomyEnum>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n}>;\n\n\nexport type GetAllTermsQuery = { terms?: { nodes: Array<{ taxonomyName?: string | null, name?: string | null, slug?: string | null, count?: number | null } | { taxonomyName?: string | null, name?: string | null, slug?: string | null, count?: number | null } | { taxonomyName?: string | null, name?: string | null, slug?: string | null, count?: number | null } | { taxonomyName?: string | null, name?: string | null, slug?: string | null, count?: number | null } | { taxonomyName?: string | null, name?: string | null, slug?: string | null, count?: number | null } | { taxonomyName?: string | null, name?: string | null, slug?: string | null, count?: number | null } | { taxonomyName?: string | null, name?: string | null, slug?: string | null, count?: number | null } | { taxonomyName?: string | null, name?: string | null, slug?: string | null, count?: number | null }> } | null };\n\nexport type GetAllowedCountriesQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GetAllowedCountriesQuery = { allowedCountries?: Array<CountriesEnum | null> | null };\n\nexport type GetBlogBySlugQueryVariables = Exact<{\n  uri: Scalars['String']['input'];\n}>;\n\n\nexport type GetBlogBySlugQuery = { nodeByUri?: { title?: string | null, date?: string | null, uri?: string | null, blog?: { blogContent?: { featuredToHome?: boolean | null, title?: string | null, shortDescription?: string | null, description?: string | null, banner?: { node: { sourceUrl?: string | null } } | null } | null, metaTags?: { metaTitle?: string | null, metaDescription?: string | null, metaImage?: { node: { sourceUrl?: string | null } } | null } | null } | null } | {} | null };\n\nexport type GetBlogsQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GetBlogsQuery = { posts?: { edges: Array<{ node: { uri?: string | null, date?: string | null, blog?: { blogContent?: { featuredToHome?: boolean | null, title?: string | null, shortDescription?: string | null, description?: string | null, banner?: { node: { sourceUrl?: string | null } } | null } | null, metaTags?: { metaTitle?: string | null, metaDescription?: string | null, metaImage?: { node: { sourceUrl?: string | null } } | null } | null } | null } }> } | null };\n\nexport type GetCartQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GetCartQuery = { cart?: { total?: string | null, subtotal?: string | null, totalTax?: string | null, discountTotal?: string | null, shippingTotal?: string | null, chosenShippingMethods?: Array<string | null> | null, isEmpty?: boolean | null, rawTotal?: string | null, rawDiscountTotal?: string | null, availableShippingMethods?: Array<{ rates?: Array<{ cost?: string | null, id: string, label?: string | null } | null> | null } | null> | null, appliedCoupons?: Array<{ description?: string | null, discountTax: string, discountAmount: string, code: string } | null> | null, contents?: { itemCount?: number | null, productCount?: number | null, nodes: Array<{ quantity?: number | null, key: string, product?: { node: { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } } | null, variation?: { node: { name?: string | null, slug?: string | null, price?: string | null, stockStatus?: StockStatusEnum | null, regularPrice?: string | null, salePrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, cartSourceUrl?: string | null } | null } } | null }> } | null } | null, customer?: { lastName?: string | null, email?: string | null, firstName?: string | null, username?: string | null, databaseId?: number | null, sessionToken?: string | null, isPayingCustomer?: boolean | null, billing?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null, shipping?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null } | null, viewer?: { lastName?: string | null, email?: string | null, databaseId: number, id: string, firstName?: string | null, username?: string | null, nicename?: string | null, wooSessionToken?: string | null, avatar?: { url?: string | null } | null } | null, paymentGateways?: { nodes: Array<{ title?: string | null, id: string, description?: string | null }> } | null };\n\nexport type ViewerFragment = { lastName?: string | null, email?: string | null, databaseId: number, id: string, firstName?: string | null, username?: string | null, nicename?: string | null, wooSessionToken?: string | null, avatar?: { url?: string | null } | null };\n\nexport type PaymentGatewayFragment = { title?: string | null, id: string, description?: string | null };\n\nexport type GetDownloadsQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GetDownloadsQuery = { customer?: { downloadableItems?: { nodes: Array<{ id: string, name?: string | null, url?: string | null, accessExpires?: string | null, downloadsRemaining?: number | null, product?: { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | null }> } | null } | null };\n\nexport type GetHomeQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GetHomeQuery = { page?: { id: string, title?: string | null, slug?: string | null, home?: { frame1?: { header?: string | null, description?: string | null } | null, frame2?: { header?: string | null, featuredProducts?: Array<{ name?: string | null, description?: string | null, image?: { node: { id: string, sourceUrl?: string | null } } | null } | null> | null } | null, frame3?: { header?: string | null, description?: string | null, image?: { node: { sourceUrl?: string | null } } | null, contactInfo?: { email?: string | null, phone?: string | null, location?: string | null, googleMapLink?: string | null } | null } | null, frame4?: { header?: string | null, packages?: Array<{ title?: string | null, description?: string | null, packageLink?: string | null, image?: { node: { sourceUrl?: string | null } } | null } | null> | null } | null, frame5?: { header?: string | null, testimonies?: Array<{ title?: string | null, description?: string | null, name?: string | null, subText?: string | null, image?: { node: { sourceUrl?: string | null } } | null } | null> | null } | null, frame6?: { header?: string | null } | null } | null } | null };\n\nexport type GetOrderQueryVariables = Exact<{\n  id: Scalars['ID']['input'];\n}>;\n\n\nexport type GetOrderQuery = { order?: { orderNumber?: string | null, date?: string | null, status?: OrderStatusEnum | null, needsPayment?: boolean | null, needsProcessing?: boolean | null, databaseId?: number | null, orderKey?: string | null, total?: string | null, subtotal?: string | null, discountTotal?: string | null, totalTax?: string | null, shippingTotal?: string | null, paymentMethodTitle?: string | null, paymentMethod?: string | null, rawDiscountTotal?: string | null, customer?: { email?: string | null, lastName?: string | null, firstName?: string | null, username?: string | null, databaseId?: number | null, sessionToken?: string | null, isPayingCustomer?: boolean | null, downloadableItems?: { nodes: Array<{ id: string, name?: string | null, url?: string | null, accessExpires?: string | null, downloadsRemaining?: number | null, product?: { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | null }> } | null, billing?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null, shipping?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null } | null, downloadableItems?: { nodes: Array<{ id: string, name?: string | null, url?: string | null, accessExpires?: string | null, downloadsRemaining?: number | null, product?: { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | null }> } | null, lineItems?: { nodes: Array<{ quantity?: number | null, total?: string | null, id: string, product?: { node: { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } | { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } | { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } | { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } } | null, variation?: { node: { name?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } } | null }> } | null } | null };\n\nexport type GetOrdersQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GetOrdersQuery = { customer?: { orders?: { nodes: Array<{ orderNumber?: string | null, date?: string | null, status?: OrderStatusEnum | null, needsPayment?: boolean | null, needsProcessing?: boolean | null, databaseId?: number | null, orderKey?: string | null, total?: string | null, subtotal?: string | null, discountTotal?: string | null, totalTax?: string | null, shippingTotal?: string | null, paymentMethodTitle?: string | null, paymentMethod?: string | null, rawDiscountTotal?: string | null, customer?: { email?: string | null, lastName?: string | null, firstName?: string | null, username?: string | null, databaseId?: number | null, sessionToken?: string | null, isPayingCustomer?: boolean | null, downloadableItems?: { nodes: Array<{ id: string, name?: string | null, url?: string | null, accessExpires?: string | null, downloadsRemaining?: number | null, product?: { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | null }> } | null, billing?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null, shipping?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null } | null, downloadableItems?: { nodes: Array<{ id: string, name?: string | null, url?: string | null, accessExpires?: string | null, downloadsRemaining?: number | null, product?: { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | null }> } | null, lineItems?: { nodes: Array<{ quantity?: number | null, total?: string | null, id: string, product?: { node: { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } | { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } | { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } | { name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } } | null, variation?: { node: { name?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null } } | null }> } | null }> } | null } | null };\n\nexport type GetProductQueryVariables = Exact<{\n  slug: Scalars['ID']['input'];\n}>;\n\n\nexport type GetProductQuery = { product?: { name?: string | null, type?: ProductTypesEnum | null, databaseId: number, id: string, slug?: string | null, sku?: string | null, description?: string | null, shortDescription?: string | null, externalUrl?: string | null, buttonText?: string | null, rawDescription?: string | null, metaData?: Array<{ id?: string | null, key: string, value?: string | null } | null> | null, attributes?: { nodes: Array<{ slug?: string | null, variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum, terms?: { nodes: Array<{ name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number }> } | null } | { variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum }> } | null, related?: { nodes: Array<{ externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | {}> } | null, reviews?: { averageRating?: number | null, edges: Array<{ rating?: number | null, node: { content?: string | null, id: string, date?: string | null, author?: { node: { name?: string | null, avatar?: { url?: string | null } | null } | { name?: string | null, avatar?: { url?: string | null } | null } } | null } }> } | null, productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null, terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null } | { name?: string | null, type?: ProductTypesEnum | null, databaseId: number, id: string, slug?: string | null, sku?: string | null, description?: string | null, shortDescription?: string | null, rawDescription?: string | null, metaData?: Array<{ id?: string | null, key: string, value?: string | null } | null> | null, attributes?: { nodes: Array<{ slug?: string | null, variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum, terms?: { nodes: Array<{ name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number }> } | null } | { variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum }> } | null, related?: { nodes: Array<{ externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | {}> } | null, reviews?: { averageRating?: number | null, edges: Array<{ rating?: number | null, node: { content?: string | null, id: string, date?: string | null, author?: { node: { name?: string | null, avatar?: { url?: string | null } | null } | { name?: string | null, avatar?: { url?: string | null } | null } } | null } }> } | null, productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null, terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null } | { name?: string | null, type?: ProductTypesEnum | null, databaseId: number, id: string, slug?: string | null, sku?: string | null, description?: string | null, shortDescription?: string | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawDescription?: string | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, metaData?: Array<{ id?: string | null, key: string, value?: string | null } | null> | null, attributes?: { nodes: Array<{ slug?: string | null, variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum, terms?: { nodes: Array<{ name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number }> } | null } | { variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum }> } | null, related?: { nodes: Array<{ externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | {}> } | null, reviews?: { averageRating?: number | null, edges: Array<{ rating?: number | null, node: { content?: string | null, id: string, date?: string | null, author?: { node: { name?: string | null, avatar?: { url?: string | null } | null } | { name?: string | null, avatar?: { url?: string | null } | null } } | null } }> } | null, productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null, terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, type?: ProductTypesEnum | null, databaseId: number, id: string, slug?: string | null, sku?: string | null, description?: string | null, shortDescription?: string | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawDescription?: string | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, metaData?: Array<{ id?: string | null, key: string, value?: string | null } | null> | null, attributes?: { nodes: Array<{ slug?: string | null, variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum, terms?: { nodes: Array<{ name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number } | { name?: string | null, slug?: string | null, taxonomyName?: string | null, databaseId: number }> } | null } | { variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum }> } | null, related?: { nodes: Array<{ externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | {}> } | null, reviews?: { averageRating?: number | null, edges: Array<{ rating?: number | null, node: { content?: string | null, id: string, date?: string | null, author?: { node: { name?: string | null, avatar?: { url?: string | null } | null } | { name?: string | null, avatar?: { url?: string | null } | null } } | null } }> } | null, productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null, terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | null };\n\ntype ProductAttribute_GlobalProductAttribute_Fragment = { variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum };\n\ntype ProductAttribute_LocalProductAttribute_Fragment = { variation?: boolean | null, name?: string | null, id: string, options?: Array<string | null> | null, label?: string | null, scope: ProductAttributeTypesEnum };\n\nexport type ProductAttributeFragment = ProductAttribute_GlobalProductAttribute_Fragment | ProductAttribute_LocalProductAttribute_Fragment;\n\nexport type CommentFragment = { content?: string | null, id: string, date?: string | null, author?: { node: { name?: string | null, avatar?: { url?: string | null } | null } | { name?: string | null, avatar?: { url?: string | null } | null } } | null };\n\nexport type GetProductCategoriesQueryVariables = Exact<{\n  first?: InputMaybe<Scalars['Int']['input']>;\n}>;\n\n\nexport type GetProductCategoriesQuery = { productCategories?: { nodes: Array<{ count?: number | null, databaseId: number, id: string, name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null }> } | null };\n\nexport type ProductCategoryFragment = { count?: number | null, databaseId: number, id: string, name?: string | null, slug?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null } | null };\n\nexport type GetProductsQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']['input']>;\n  slug?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderby?: InputMaybe<ProductsOrderByEnum>;\n}>;\n\n\nexport type GetProductsQuery = { products?: { pageInfo: { hasNextPage: boolean, endCursor?: string | null }, nodes: Array<{ name?: string | null, slug?: string | null, type?: ProductTypesEnum | null, databaseId: number, id: string, averageRating?: number | null, reviewCount?: number | null, externalUrl?: string | null, buttonText?: string | null, terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null, productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null } | { name?: string | null, slug?: string | null, type?: ProductTypesEnum | null, databaseId: number, id: string, averageRating?: number | null, reviewCount?: number | null, terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null, productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null } | { name?: string | null, slug?: string | null, type?: ProductTypesEnum | null, databaseId: number, id: string, averageRating?: number | null, reviewCount?: number | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null, productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, type?: ProductTypesEnum | null, databaseId: number, id: string, averageRating?: number | null, reviewCount?: number | null } | { name?: string | null, slug?: string | null, type?: ProductTypesEnum | null, databaseId: number, id: string, averageRating?: number | null, reviewCount?: number | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, terms?: { nodes: Array<{ taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null } | { taxonomyName?: string | null, slug?: string | null }> } | null, productCategories?: { nodes: Array<{ databaseId: number, slug?: string | null, name?: string | null, count?: number | null }> } | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null }> } | null };\n\nexport type GetStatesQueryVariables = Exact<{\n  country: CountriesEnum;\n}>;\n\n\nexport type GetStatesQuery = { countryStates?: Array<{ code: string, name: string } | null> | null };\n\nexport type GetStockStatusQueryVariables = Exact<{\n  slug: Scalars['ID']['input'];\n}>;\n\n\nexport type GetStockStatusQuery = { product?: { stockStatus?: StockStatusEnum | null } | { stockStatus?: StockStatusEnum | null, variations?: { nodes: Array<{ stockStatus?: StockStatusEnum | null }> } | null } | {} | null };\n\nexport type GetStripePaymentIntentQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GetStripePaymentIntentQuery = { stripePaymentIntent?: { amount?: number | null, clientSecret?: string | null, error?: string | null, id?: string | null, currency?: string | null } | null };\n\nexport type LoginMutationVariables = Exact<{\n  username: Scalars['String']['input'];\n  password: Scalars['String']['input'];\n}>;\n\n\nexport type LoginMutation = { loginWithCookies?: { status?: string | null } | null };\n\nexport type LogoutMutationVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type LogoutMutation = { logout?: { status?: string | null } | null };\n\nexport type RegisterCustomerMutationVariables = Exact<{\n  input: RegisterCustomerInput;\n}>;\n\n\nexport type RegisterCustomerMutation = { registerCustomer?: { customer?: { lastName?: string | null, email?: string | null, firstName?: string | null, username?: string | null, databaseId?: number | null, sessionToken?: string | null, isPayingCustomer?: boolean | null, billing?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null, shipping?: { address1?: string | null, address2?: string | null, city?: string | null, country?: CountriesEnum | null, email?: string | null, firstName?: string | null, lastName?: string | null, phone?: string | null, postcode?: string | null, company?: string | null, state?: string | null } | null } | null } | null };\n\nexport type RemoveCouponsMutationVariables = Exact<{\n  codes: Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>;\n}>;\n\n\nexport type RemoveCouponsMutation = { removeCoupons?: { cart?: { total?: string | null, subtotal?: string | null, totalTax?: string | null, discountTotal?: string | null, shippingTotal?: string | null, chosenShippingMethods?: Array<string | null> | null, isEmpty?: boolean | null, rawTotal?: string | null, rawDiscountTotal?: string | null, availableShippingMethods?: Array<{ rates?: Array<{ cost?: string | null, id: string, label?: string | null } | null> | null } | null> | null, appliedCoupons?: Array<{ description?: string | null, discountTax: string, discountAmount: string, code: string } | null> | null, contents?: { itemCount?: number | null, productCount?: number | null, nodes: Array<{ quantity?: number | null, key: string, product?: { node: { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } } | null, variation?: { node: { name?: string | null, slug?: string | null, price?: string | null, stockStatus?: StockStatusEnum | null, regularPrice?: string | null, salePrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, cartSourceUrl?: string | null } | null } } | null }> } | null } | null } | null };\n\nexport type ResetPasswordEmailMutationVariables = Exact<{\n  username: Scalars['String']['input'];\n}>;\n\n\nexport type ResetPasswordEmailMutation = { sendPasswordResetEmail?: { success?: boolean | null } | null };\n\nexport type ResetPasswordKeyMutationVariables = Exact<{\n  key: Scalars['String']['input'];\n  login: Scalars['String']['input'];\n  password: Scalars['String']['input'];\n}>;\n\n\nexport type ResetPasswordKeyMutation = { resetUserPassword?: { user?: { id: string } | null } | null };\n\nexport type UpDateCartQuantityMutationVariables = Exact<{\n  key: Scalars['ID']['input'];\n  quantity: Scalars['Int']['input'];\n}>;\n\n\nexport type UpDateCartQuantityMutation = { updateItemQuantities?: { cart?: { total?: string | null, subtotal?: string | null, totalTax?: string | null, discountTotal?: string | null, shippingTotal?: string | null, chosenShippingMethods?: Array<string | null> | null, isEmpty?: boolean | null, rawTotal?: string | null, rawDiscountTotal?: string | null, availableShippingMethods?: Array<{ rates?: Array<{ cost?: string | null, id: string, label?: string | null } | null> | null } | null> | null, appliedCoupons?: Array<{ description?: string | null, discountTax: string, discountAmount: string, code: string } | null> | null, contents?: { itemCount?: number | null, productCount?: number | null, nodes: Array<{ quantity?: number | null, key: string, product?: { node: { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, externalUrl?: string | null, buttonText?: string | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, stockQuantity?: number | null, lowStockAmount?: number | null, averageRating?: number | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, reviewCount?: number | null, onSale?: boolean | null, virtual?: boolean | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } | { name?: string | null, slug?: string | null, sku?: string | null, databaseId: number, type?: ProductTypesEnum | null, price?: string | null, date?: string | null, weight?: string | null, length?: string | null, width?: string | null, height?: string | null, averageRating?: number | null, reviewCount?: number | null, onSale?: boolean | null, regularPrice?: string | null, salePrice?: string | null, stockStatus?: StockStatusEnum | null, totalSales?: number | null, stockQuantity?: number | null, lowStockAmount?: number | null, rawPrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, defaultAttributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null, variations?: { nodes: Array<{ name?: string | null, databaseId: number, price?: string | null, regularPrice?: string | null, salePrice?: string | null, slug?: string | null, stockQuantity?: number | null, stockStatus?: StockStatusEnum | null, hasAttributes?: boolean | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, databaseId: number, cartSourceUrl?: string | null, producCardSourceUrl?: string | null } | null, attributes?: { nodes: Array<{ name?: string | null, attributeId?: number | null, value?: string | null, label?: string | null }> } | null }> } | null, galleryImages?: { nodes: Array<{ databaseId: number, sourceUrl?: string | null, altText?: string | null, title?: string | null }> } | null } } | null, variation?: { node: { name?: string | null, slug?: string | null, price?: string | null, stockStatus?: StockStatusEnum | null, regularPrice?: string | null, salePrice?: string | null, rawRegularPrice?: string | null, rawSalePrice?: string | null, image?: { sourceUrl?: string | null, altText?: string | null, title?: string | null, cartSourceUrl?: string | null } | null } } | null }> } | null } | null } | null };\n\nexport type UpdateCustomerMutationVariables = Exact<{\n  input: UpdateCustomerInput;\n}>;\n\n\nexport type UpdateCustomerMutation = { updateCustomer?: { customer?: { downloadableItems?: { nodes: Array<{ id: string, name?: string | null, url?: string | null, accessExpires?: string | null, downloadsRemaining?: number | null, product?: { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | { name?: string | null, slug?: string | null } | null }> } | null } | null } | null };\n\nexport type UpdatePasswordMutationVariables = Exact<{\n  id: Scalars['ID']['input'];\n  password: Scalars['String']['input'];\n}>;\n\n\nexport type UpdatePasswordMutation = { updateUser?: { user?: { id: string } | null } | null };\n\nexport type WriteReviewMutationVariables = Exact<{\n  author: Scalars['String']['input'];\n  commentOn: Scalars['Int']['input'];\n  content: Scalars['String']['input'];\n  rating: Scalars['Int']['input'];\n  authorEmail: Scalars['String']['input'];\n}>;\n\n\nexport type WriteReviewMutation = { writeReview?: { rating?: number | null } | null };\n\nexport const ImageFragmentDoc = gql`\n    fragment Image on MediaItem {\n  sourceUrl\n  altText\n  title\n  databaseId\n}\n    `;\nexport const SimpleProductFragmentDoc = gql`\n    fragment SimpleProduct on SimpleProduct {\n  name\n  slug\n  price\n  rawPrice: price(format: RAW)\n  date\n  regularPrice\n  rawRegularPrice: regularPrice(format: RAW)\n  salePrice\n  rawSalePrice: salePrice(format: RAW)\n  stockStatus\n  stockQuantity\n  lowStockAmount\n  averageRating\n  weight\n  length\n  width\n  height\n  reviewCount\n  onSale\n  virtual\n  image {\n    ...Image\n    cartSourceUrl: sourceUrl(size: THUMBNAIL)\n    producCardSourceUrl: sourceUrl(size: WOOCOMMERCE_THUMBNAIL)\n  }\n  galleryImages(first: 20) {\n    nodes {\n      ...Image\n      databaseId\n    }\n  }\n}\n    `;\nexport const VariationAttributeFragmentDoc = gql`\n    fragment VariationAttribute on VariationAttribute {\n  name\n  attributeId\n  value\n  label\n}\n    `;\nexport const VariableProductFragmentDoc = gql`\n    fragment VariableProduct on VariableProduct {\n  name\n  slug\n  price\n  rawPrice: price(format: RAW)\n  date\n  weight\n  length\n  width\n  height\n  image {\n    ...Image\n    cartSourceUrl: sourceUrl(size: THUMBNAIL)\n    producCardSourceUrl: sourceUrl(size: WOOCOMMERCE_THUMBNAIL)\n  }\n  averageRating\n  reviewCount\n  onSale\n  regularPrice\n  rawRegularPrice: regularPrice(format: RAW)\n  salePrice\n  rawSalePrice: salePrice(format: RAW)\n  stockStatus\n  totalSales\n  stockQuantity\n  lowStockAmount\n  defaultAttributes {\n    nodes {\n      ...VariationAttribute\n    }\n  }\n  variations(first: 100) {\n    nodes {\n      name\n      databaseId\n      price\n      regularPrice\n      salePrice\n      rawSalePrice: salePrice(format: RAW)\n      slug\n      stockQuantity\n      stockStatus\n      hasAttributes\n      image {\n        ...Image\n        cartSourceUrl: sourceUrl(size: THUMBNAIL)\n        producCardSourceUrl: sourceUrl(size: WOOCOMMERCE_THUMBNAIL)\n      }\n      attributes {\n        nodes {\n          ...VariationAttribute\n        }\n      }\n    }\n  }\n  galleryImages(first: 20) {\n    nodes {\n      ...Image\n      databaseId\n    }\n  }\n}\n    `;\nexport const ExternalProductFragmentDoc = gql`\n    fragment ExternalProduct on ExternalProduct {\n  externalUrl\n  buttonText\n}\n    `;\nexport const CartFragmentDoc = gql`\n    fragment Cart on Cart {\n  total\n  rawTotal: total(format: RAW)\n  subtotal\n  totalTax\n  discountTotal\n  rawDiscountTotal: discountTotal(format: RAW)\n  shippingTotal\n  chosenShippingMethods\n  availableShippingMethods {\n    rates {\n      cost\n      id\n      label\n    }\n  }\n  appliedCoupons {\n    description\n    discountTax\n    discountAmount\n    code\n  }\n  isEmpty\n  contents(first: 100) {\n    itemCount\n    productCount\n    nodes {\n      quantity\n      key\n      product {\n        node {\n          name\n          slug\n          sku\n          databaseId\n          type\n          ...SimpleProduct\n          ...VariableProduct\n          ...ExternalProduct\n        }\n      }\n      variation {\n        node {\n          name\n          slug\n          price\n          stockStatus\n          regularPrice\n          rawRegularPrice: regularPrice(format: RAW)\n          salePrice\n          rawSalePrice: salePrice(format: RAW)\n          image {\n            sourceUrl(size: THUMBNAIL)\n            cartSourceUrl: sourceUrl(size: THUMBNAIL)\n            altText\n            title\n          }\n        }\n      }\n    }\n  }\n}\n    `;\nexport const DownloadableItemFragmentDoc = gql`\n    fragment DownloadableItem on DownloadableItem {\n  id\n  name\n  product {\n    name\n    slug\n  }\n  url\n  accessExpires\n  downloadsRemaining\n}\n    `;\nexport const AddressFragmentDoc = gql`\n    fragment Address on CustomerAddress {\n  address1\n  address2\n  city\n  country\n  email\n  firstName\n  lastName\n  phone\n  postcode\n  company\n  state\n}\n    `;\nexport const CustomerFragmentDoc = gql`\n    fragment Customer on Customer {\n  lastName\n  email\n  firstName\n  username\n  databaseId\n  sessionToken\n  isPayingCustomer\n  billing {\n    ...Address\n  }\n  shipping {\n    ...Address\n  }\n}\n    `;\nexport const OrderFragmentFragmentDoc = gql`\n    fragment OrderFragment on Order {\n  orderNumber\n  date\n  status\n  needsPayment\n  needsProcessing\n  databaseId\n  orderKey\n  total\n  subtotal\n  discountTotal\n  rawDiscountTotal: discountTotal(format: RAW)\n  totalTax\n  shippingTotal\n  paymentMethodTitle\n  paymentMethod\n  customer {\n    email\n    downloadableItems(first: 100) {\n      nodes {\n        ...DownloadableItem\n      }\n    }\n  }\n  downloadableItems(first: 100) {\n    nodes {\n      ...DownloadableItem\n    }\n  }\n  lineItems {\n    nodes {\n      quantity\n      total\n      id\n      product {\n        node {\n          name\n          slug\n          image {\n            sourceUrl(size: THUMBNAIL)\n            altText\n            title\n          }\n        }\n      }\n      variation {\n        node {\n          name\n          image {\n            sourceUrl(size: THUMBNAIL)\n            altText\n            title\n          }\n        }\n      }\n    }\n  }\n  customer {\n    ...Customer\n  }\n}\n    `;\nexport const ProductCategoriesFragmentDoc = gql`\n    fragment ProductCategories on Product {\n  productCategories {\n    nodes {\n      databaseId\n      slug\n      name\n      count\n    }\n  }\n}\n    `;\nexport const TermsFragmentDoc = gql`\n    fragment Terms on Product {\n  terms(first: 100) {\n    nodes {\n      taxonomyName\n      slug\n    }\n  }\n}\n    `;\nexport const ViewerFragmentDoc = gql`\n    fragment Viewer on User {\n  lastName\n  email\n  databaseId\n  id\n  firstName\n  username\n  nicename\n  wooSessionToken\n  avatar {\n    url\n  }\n}\n    `;\nexport const PaymentGatewayFragmentDoc = gql`\n    fragment PaymentGateway on PaymentGateway {\n  title\n  id\n  description\n}\n    `;\nexport const ProductAttributeFragmentDoc = gql`\n    fragment ProductAttribute on ProductAttribute {\n  variation\n  name\n  id\n  options\n  label\n  scope\n}\n    `;\nexport const CommentFragmentDoc = gql`\n    fragment Comment on Comment {\n  content\n  id\n  date\n  author {\n    node {\n      name\n      avatar {\n        url\n      }\n    }\n  }\n}\n    `;\nexport const ProductCategoryFragmentDoc = gql`\n    fragment ProductCategory on ProductCategory {\n  count\n  databaseId\n  id\n  name\n  slug\n  image {\n    sourceUrl(size: MEDIUM_LARGE)\n    altText\n    title\n  }\n}\n    `;\nexport const AddToCartDocument = gql`\n    mutation addToCart($input: AddToCartInput!) {\n  addToCart(input: $input) {\n    cart {\n      ...Cart\n    }\n  }\n}\n    ${CartFragmentDoc}\n${SimpleProductFragmentDoc}\n${ImageFragmentDoc}\n${VariableProductFragmentDoc}\n${VariationAttributeFragmentDoc}\n${ExternalProductFragmentDoc}`;\nexport const ApplyCouponDocument = gql`\n    mutation applyCoupon($code: String!) {\n  applyCoupon(input: {code: $code}) {\n    applied {\n      code\n      description\n      discountTax\n      discountAmount\n    }\n    cart {\n      ...Cart\n    }\n  }\n}\n    ${CartFragmentDoc}\n${SimpleProductFragmentDoc}\n${ImageFragmentDoc}\n${VariableProductFragmentDoc}\n${VariationAttributeFragmentDoc}\n${ExternalProductFragmentDoc}`;\nexport const ChangeShippingCountyDocument = gql`\n    mutation ChangeShippingCounty($shippingState: String!, $shippingCountry: CountriesEnum!, $billingState: String!, $billingCountry: CountriesEnum!) {\n  updateCustomer(\n    input: {shipping: {state: $shippingState, country: $shippingCountry}, billing: {state: $billingState, country: $billingCountry}}\n  ) {\n    customer {\n      calculatedShipping\n      hasCalculatedShipping\n    }\n  }\n}\n    `;\nexport const ChangeShippingMethodDocument = gql`\n    mutation ChangeShippingMethod($shippingMethods: [String] = \"\") {\n  updateShippingMethod(input: {shippingMethods: $shippingMethods}) {\n    cart {\n      ...Cart\n    }\n  }\n}\n    ${CartFragmentDoc}\n${SimpleProductFragmentDoc}\n${ImageFragmentDoc}\n${VariableProductFragmentDoc}\n${VariationAttributeFragmentDoc}\n${ExternalProductFragmentDoc}`;\nexport const CheckoutDocument = gql`\n    mutation Checkout($billing: CustomerAddressInput = {}, $metaData: [MetaDataInput] = {key: \"\", value: \"\"}, $paymentMethod: String = \"stripe\", $shipping: CustomerAddressInput = {}, $customerNote: String = \"\", $shipToDifferentAddress: Boolean = false, $account: CreateAccountInput = {username: \"\", password: \"\"}, $transactionId: String = \"\", $isPaid: Boolean = false) {\n  checkout(\n    input: {paymentMethod: $paymentMethod, billing: $billing, metaData: $metaData, shipping: $shipping, customerNote: $customerNote, shipToDifferentAddress: $shipToDifferentAddress, account: $account, transactionId: $transactionId, isPaid: $isPaid}\n  ) {\n    result\n    redirect\n    order {\n      needsPayment\n      needsProcessing\n      status\n      databaseId\n      orderKey\n      subtotal\n      total\n      subtotal\n      totalTax\n      shippingTotal\n      paymentMethodTitle\n      paymentMethod\n      date\n      subtotal\n      customer {\n        email\n      }\n      lineItems {\n        nodes {\n          quantity\n          total\n          product {\n            node {\n              name\n              image {\n                ...Image\n              }\n            }\n          }\n          variation {\n            node {\n              name\n              image {\n                ...Image\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    ${ImageFragmentDoc}`;\nexport const EmptyCartDocument = gql`\n    mutation EmptyCart {\n  emptyCart(input: {clearPersistentCart: true}) {\n    cart {\n      ...Cart\n    }\n  }\n}\n    ${CartFragmentDoc}\n${SimpleProductFragmentDoc}\n${ImageFragmentDoc}\n${VariableProductFragmentDoc}\n${VariationAttributeFragmentDoc}\n${ExternalProductFragmentDoc}`;\nexport const GetAllTermsDocument = gql`\n    query getAllTerms($hideEmpty: Boolean = true, $taxonomies: [TaxonomyEnum]!, $first: Int = 100) {\n  terms(where: {taxonomies: $taxonomies, hideEmpty: $hideEmpty}, first: $first) {\n    nodes {\n      taxonomyName\n      name\n      slug\n      count\n    }\n  }\n}\n    `;\nexport const GetAllowedCountriesDocument = gql`\n    query getAllowedCountries {\n  allowedCountries\n}\n    `;\nexport const GetBlogBySlugDocument = gql`\n    query getBlogBySlug($uri: String!) {\n  nodeByUri(uri: $uri) {\n    ... on Post {\n      title\n      date\n      uri\n      ... on WithAcfBlog {\n        blog {\n          blogContent {\n            featuredToHome\n            title\n            shortDescription\n            banner {\n              node {\n                sourceUrl\n              }\n            }\n            description\n          }\n          metaTags {\n            metaTitle\n            metaDescription\n            metaImage {\n              node {\n                sourceUrl\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    `;\nexport const GetBlogsDocument = gql`\n    query getBlogs {\n  posts {\n    edges {\n      node {\n        uri\n        date\n        ... on WithAcfBlog {\n          blog {\n            blogContent {\n              featuredToHome\n              title\n              shortDescription\n              banner {\n                node {\n                  sourceUrl\n                }\n              }\n              description\n            }\n            metaTags {\n              metaTitle\n              metaDescription\n              metaImage {\n                node {\n                  sourceUrl\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    `;\nexport const GetCartDocument = gql`\n    query getCart {\n  cart {\n    ...Cart\n  }\n  customer {\n    ...Customer\n  }\n  viewer {\n    ...Viewer\n  }\n  paymentGateways {\n    nodes {\n      ...PaymentGateway\n    }\n  }\n}\n    ${CartFragmentDoc}\n${SimpleProductFragmentDoc}\n${ImageFragmentDoc}\n${VariableProductFragmentDoc}\n${VariationAttributeFragmentDoc}\n${ExternalProductFragmentDoc}\n${CustomerFragmentDoc}\n${AddressFragmentDoc}\n${ViewerFragmentDoc}\n${PaymentGatewayFragmentDoc}`;\nexport const GetDownloadsDocument = gql`\n    query getDownloads {\n  customer {\n    downloadableItems(first: 100) {\n      nodes {\n        ...DownloadableItem\n      }\n    }\n  }\n}\n    ${DownloadableItemFragmentDoc}`;\nexport const GetHomeDocument = gql`\n    query getHome {\n  page(id: \"home\", idType: URI) {\n    id\n    title\n    slug\n    ... on WithAcfHome {\n      home {\n        frame1 {\n          header\n          description\n        }\n        frame2 {\n          header\n          featuredProducts {\n            name\n            description\n            image {\n              node {\n                id\n                sourceUrl\n              }\n            }\n          }\n        }\n        frame3 {\n          header\n          description\n          image {\n            node {\n              sourceUrl\n            }\n          }\n          contactInfo {\n            email\n            phone\n            location\n            googleMapLink\n          }\n        }\n        frame4 {\n          header\n          packages {\n            title\n            description\n            image {\n              node {\n                sourceUrl\n              }\n            }\n            packageLink\n          }\n        }\n        frame5 {\n          header\n          testimonies {\n            title\n            description\n            image {\n              node {\n                sourceUrl\n              }\n            }\n            name\n            subText\n          }\n        }\n        frame6 {\n          header\n        }\n      }\n    }\n  }\n}\n    `;\nexport const GetOrderDocument = gql`\n    query getOrder($id: ID!) {\n  order(id: $id, idType: DATABASE_ID) {\n    ...OrderFragment\n  }\n}\n    ${OrderFragmentFragmentDoc}\n${DownloadableItemFragmentDoc}\n${CustomerFragmentDoc}\n${AddressFragmentDoc}`;\nexport const GetOrdersDocument = gql`\n    query getOrders {\n  customer {\n    orders(first: 100) {\n      nodes {\n        ...OrderFragment\n      }\n    }\n  }\n}\n    ${OrderFragmentFragmentDoc}\n${DownloadableItemFragmentDoc}\n${CustomerFragmentDoc}\n${AddressFragmentDoc}`;\nexport const GetProductDocument = gql`\n    query getProduct($slug: ID!) {\n  product(id: $slug, idType: SLUG) {\n    name\n    type\n    databaseId\n    id\n    metaData {\n      id\n      key\n      value\n    }\n    slug\n    sku\n    description\n    rawDescription: description(format: RAW)\n    shortDescription\n    attributes {\n      nodes {\n        ...ProductAttribute\n        ... on GlobalProductAttribute {\n          slug\n          terms(where: {orderby: MENU_ORDER, order: ASC}) {\n            nodes {\n              name\n              slug\n              taxonomyName\n              databaseId\n            }\n          }\n        }\n      }\n    }\n    ...ProductCategories\n    ...Terms\n    ...SimpleProduct\n    ...VariableProduct\n    ...ExternalProduct\n    related(first: 5) {\n      nodes {\n        ...SimpleProduct\n        ...VariableProduct\n        ...ExternalProduct\n      }\n    }\n    reviews {\n      averageRating\n      edges {\n        rating\n        node {\n          ...Comment\n        }\n      }\n    }\n  }\n}\n    ${ProductAttributeFragmentDoc}\n${ProductCategoriesFragmentDoc}\n${TermsFragmentDoc}\n${SimpleProductFragmentDoc}\n${ImageFragmentDoc}\n${VariableProductFragmentDoc}\n${VariationAttributeFragmentDoc}\n${ExternalProductFragmentDoc}\n${CommentFragmentDoc}`;\nexport const GetProductCategoriesDocument = gql`\n    query getProductCategories($first: Int = 20) {\n  productCategories(\n    first: $first\n    where: {orderby: COUNT, order: DESC, hideEmpty: true}\n  ) {\n    nodes {\n      ...ProductCategory\n    }\n  }\n}\n    ${ProductCategoryFragmentDoc}`;\nexport const GetProductsDocument = gql`\n    query getProducts($after: String, $slug: [String], $first: Int = 9999, $orderby: ProductsOrderByEnum = DATE) {\n  products(\n    first: $first\n    after: $after\n    where: {categoryIn: $slug, visibility: VISIBLE, minPrice: 0, orderby: {field: $orderby, order: DESC}, status: \"publish\"}\n  ) {\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    nodes {\n      name\n      slug\n      type\n      databaseId\n      id\n      averageRating\n      reviewCount\n      ...Terms\n      ...ProductCategories\n      ...SimpleProduct\n      ...VariableProduct\n      ...ExternalProduct\n    }\n  }\n}\n    ${TermsFragmentDoc}\n${ProductCategoriesFragmentDoc}\n${SimpleProductFragmentDoc}\n${ImageFragmentDoc}\n${VariableProductFragmentDoc}\n${VariationAttributeFragmentDoc}\n${ExternalProductFragmentDoc}`;\nexport const GetStatesDocument = gql`\n    query getStates($country: CountriesEnum!) {\n  countryStates(country: $country) {\n    code\n    name\n  }\n}\n    `;\nexport const GetStockStatusDocument = gql`\n    query getStockStatus($slug: ID!) {\n  product(id: $slug, idType: SLUG) {\n    ... on SimpleProduct {\n      stockStatus\n    }\n    ... on VariableProduct {\n      stockStatus\n      variations {\n        nodes {\n          stockStatus\n        }\n      }\n    }\n  }\n}\n    `;\nexport const GetStripePaymentIntentDocument = gql`\n    query getStripePaymentIntent {\n  stripePaymentIntent {\n    amount\n    clientSecret\n    error\n    id\n    currency\n  }\n}\n    `;\nexport const LoginDocument = gql`\n    mutation login($username: String!, $password: String!) {\n  loginWithCookies(\n    input: {login: $username, password: $password, rememberMe: true}\n  ) {\n    status\n  }\n}\n    `;\nexport const LogoutDocument = gql`\n    mutation Logout {\n  logout(input: {clientMutationId: \"\"}) {\n    status\n  }\n}\n    `;\nexport const RegisterCustomerDocument = gql`\n    mutation registerCustomer($input: RegisterCustomerInput!) {\n  registerCustomer(input: $input) {\n    customer {\n      ...Customer\n    }\n  }\n}\n    ${CustomerFragmentDoc}\n${AddressFragmentDoc}`;\nexport const RemoveCouponsDocument = gql`\n    mutation removeCoupons($codes: [String]!) {\n  removeCoupons(input: {codes: $codes}) {\n    cart {\n      ...Cart\n    }\n  }\n}\n    ${CartFragmentDoc}\n${SimpleProductFragmentDoc}\n${ImageFragmentDoc}\n${VariableProductFragmentDoc}\n${VariationAttributeFragmentDoc}\n${ExternalProductFragmentDoc}`;\nexport const ResetPasswordEmailDocument = gql`\n    mutation ResetPasswordEmail($username: String!) {\n  sendPasswordResetEmail(input: {username: $username}) {\n    success\n  }\n}\n    `;\nexport const ResetPasswordKeyDocument = gql`\n    mutation ResetPasswordKey($key: String!, $login: String!, $password: String!) {\n  resetUserPassword(input: {key: $key, login: $login, password: $password}) {\n    user {\n      id\n    }\n  }\n}\n    `;\nexport const UpDateCartQuantityDocument = gql`\n    mutation UpDateCartQuantity($key: ID!, $quantity: Int!) {\n  updateItemQuantities(input: {items: {key: $key, quantity: $quantity}}) {\n    cart {\n      ...Cart\n    }\n  }\n}\n    ${CartFragmentDoc}\n${SimpleProductFragmentDoc}\n${ImageFragmentDoc}\n${VariableProductFragmentDoc}\n${VariationAttributeFragmentDoc}\n${ExternalProductFragmentDoc}`;\nexport const UpdateCustomerDocument = gql`\n    mutation UpdateCustomer($input: UpdateCustomerInput!) {\n  updateCustomer(input: $input) {\n    customer {\n      downloadableItems(first: 100) {\n        nodes {\n          ...DownloadableItem\n        }\n      }\n    }\n  }\n}\n    ${DownloadableItemFragmentDoc}`;\nexport const UpdatePasswordDocument = gql`\n    mutation updatePassword($id: ID!, $password: String!) {\n  updateUser(input: {id: $id, password: $password}) {\n    user {\n      id\n    }\n  }\n}\n    `;\nexport const WriteReviewDocument = gql`\n    mutation WriteReview($author: String!, $commentOn: Int!, $content: String!, $rating: Int!, $authorEmail: String!) {\n  writeReview(\n    input: {rating: $rating, author: $author, content: $content, commentOn: $commentOn, authorEmail: $authorEmail}\n  ) {\n    rating\n  }\n}\n    `;\n\nexport type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string, variables?: any) => Promise<T>;\n\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType, _variables) => action();\n\nexport function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {\n  return {\n    addToCart(variables: AddToCartMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<AddToCartMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<AddToCartMutation>(AddToCartDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'addToCart', 'mutation', variables);\n    },\n    applyCoupon(variables: ApplyCouponMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ApplyCouponMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<ApplyCouponMutation>(ApplyCouponDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'applyCoupon', 'mutation', variables);\n    },\n    ChangeShippingCounty(variables: ChangeShippingCountyMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ChangeShippingCountyMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<ChangeShippingCountyMutation>(ChangeShippingCountyDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ChangeShippingCounty', 'mutation', variables);\n    },\n    ChangeShippingMethod(variables?: ChangeShippingMethodMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ChangeShippingMethodMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<ChangeShippingMethodMutation>(ChangeShippingMethodDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ChangeShippingMethod', 'mutation', variables);\n    },\n    Checkout(variables?: CheckoutMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CheckoutMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<CheckoutMutation>(CheckoutDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'Checkout', 'mutation', variables);\n    },\n    EmptyCart(variables?: EmptyCartMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<EmptyCartMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<EmptyCartMutation>(EmptyCartDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'EmptyCart', 'mutation', variables);\n    },\n    getAllTerms(variables: GetAllTermsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAllTermsQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetAllTermsQuery>(GetAllTermsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAllTerms', 'query', variables);\n    },\n    getAllowedCountries(variables?: GetAllowedCountriesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAllowedCountriesQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetAllowedCountriesQuery>(GetAllowedCountriesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAllowedCountries', 'query', variables);\n    },\n    getBlogBySlug(variables: GetBlogBySlugQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetBlogBySlugQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetBlogBySlugQuery>(GetBlogBySlugDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getBlogBySlug', 'query', variables);\n    },\n    getBlogs(variables?: GetBlogsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetBlogsQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetBlogsQuery>(GetBlogsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getBlogs', 'query', variables);\n    },\n    getCart(variables?: GetCartQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCartQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetCartQuery>(GetCartDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCart', 'query', variables);\n    },\n    getDownloads(variables?: GetDownloadsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetDownloadsQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetDownloadsQuery>(GetDownloadsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getDownloads', 'query', variables);\n    },\n    getHome(variables?: GetHomeQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetHomeQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetHomeQuery>(GetHomeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getHome', 'query', variables);\n    },\n    getOrder(variables: GetOrderQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetOrderQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetOrderQuery>(GetOrderDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getOrder', 'query', variables);\n    },\n    getOrders(variables?: GetOrdersQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetOrdersQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetOrdersQuery>(GetOrdersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getOrders', 'query', variables);\n    },\n    getProduct(variables: GetProductQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProductQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetProductQuery>(GetProductDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProduct', 'query', variables);\n    },\n    getProductCategories(variables?: GetProductCategoriesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProductCategoriesQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetProductCategoriesQuery>(GetProductCategoriesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProductCategories', 'query', variables);\n    },\n    getProducts(variables?: GetProductsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProductsQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetProductsQuery>(GetProductsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProducts', 'query', variables);\n    },\n    getStates(variables: GetStatesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStatesQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetStatesQuery>(GetStatesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStates', 'query', variables);\n    },\n    getStockStatus(variables: GetStockStatusQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStockStatusQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetStockStatusQuery>(GetStockStatusDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStockStatus', 'query', variables);\n    },\n    getStripePaymentIntent(variables?: GetStripePaymentIntentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStripePaymentIntentQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GetStripePaymentIntentQuery>(GetStripePaymentIntentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStripePaymentIntent', 'query', variables);\n    },\n    login(variables: LoginMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<LoginMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<LoginMutation>(LoginDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'login', 'mutation', variables);\n    },\n    Logout(variables?: LogoutMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<LogoutMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<LogoutMutation>(LogoutDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'Logout', 'mutation', variables);\n    },\n    registerCustomer(variables: RegisterCustomerMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RegisterCustomerMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<RegisterCustomerMutation>(RegisterCustomerDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'registerCustomer', 'mutation', variables);\n    },\n    removeCoupons(variables: RemoveCouponsMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RemoveCouponsMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<RemoveCouponsMutation>(RemoveCouponsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'removeCoupons', 'mutation', variables);\n    },\n    ResetPasswordEmail(variables: ResetPasswordEmailMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ResetPasswordEmailMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<ResetPasswordEmailMutation>(ResetPasswordEmailDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ResetPasswordEmail', 'mutation', variables);\n    },\n    ResetPasswordKey(variables: ResetPasswordKeyMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ResetPasswordKeyMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<ResetPasswordKeyMutation>(ResetPasswordKeyDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ResetPasswordKey', 'mutation', variables);\n    },\n    UpDateCartQuantity(variables: UpDateCartQuantityMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UpDateCartQuantityMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<UpDateCartQuantityMutation>(UpDateCartQuantityDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'UpDateCartQuantity', 'mutation', variables);\n    },\n    UpdateCustomer(variables: UpdateCustomerMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UpdateCustomerMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<UpdateCustomerMutation>(UpdateCustomerDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'UpdateCustomer', 'mutation', variables);\n    },\n    updatePassword(variables: UpdatePasswordMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UpdatePasswordMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<UpdatePasswordMutation>(UpdatePasswordDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'updatePassword', 'mutation', variables);\n    },\n    WriteReview(variables: WriteReviewMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<WriteReviewMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<WriteReviewMutation>(WriteReviewDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'WriteReview', 'mutation', variables);\n    }\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;"],"names":["OrderStatusEnum","ProductTypesEnum","ProductsOrderByEnum","StockStatusEnum","TaxonomyEnum"],"mappings":";AAuqGY,IAAA,oCAAAA,qBAAL;AAELA,mBAAA,WAAY,IAAA;AAEZA,mBAAA,gBAAiB,IAAA;AAEjBA,mBAAA,WAAY,IAAA;AAEZA,mBAAA,QAAS,IAAA;AAETA,mBAAA,SAAU,IAAA;AAEVA,mBAAA,SAAU,IAAA;AAEVA,mBAAA,YAAa,IAAA;AAEbA,mBAAA,UAAW,IAAA;AAhBDA,SAAAA;AAAA,GAAA,mBAAA,CAAA,CAAA;AAk5EA,IAAA,qCAAAC,sBAAL;AAELA,oBAAA,UAAW,IAAA;AAEXA,oBAAA,SAAU,IAAA;AAEVA,oBAAA,QAAS,IAAA;AAETA,oBAAA,UAAW,IAAA;AAEXA,oBAAA,WAAY,IAAA;AAVFA,SAAAA;AAAA,GAAA,oBAAA,CAAA,CAAA;AA8HA,IAAA,wCAAAC,yBAAL;AAELA,uBAAA,MAAO,IAAA;AAEPA,uBAAA,IAAK,IAAA;AAELA,uBAAA,YAAa,IAAA;AAEbA,uBAAA,UAAW,IAAA;AAEXA,uBAAA,MAAO,IAAA;AAEPA,uBAAA,SAAU,IAAA;AAKVA,uBAAA,cAAe,IAAA;AAKfA,uBAAA,YAAa,IAAA;AAEbA,uBAAA,QAAS,IAAA;AAETA,uBAAA,YAAa,IAAA;AAEbA,uBAAA,OAAQ,IAAA;AAERA,uBAAA,QAAS,IAAA;AAKTA,uBAAA,eAAgB,IAAA;AAEhBA,uBAAA,cAAe,IAAA;AAKfA,uBAAA,YAAa,IAAA;AAEbA,uBAAA,MAAO,IAAA;AAKPA,uBAAA,aAAc,IAAA;AAjDJA,SAAAA;AAAA,GAAA,uBAAA,CAAA,CAAA;AAq9CA,IAAA,oCAAAC,qBAAL;AACLA,mBAAA,UAAW,IAAA;AACXA,mBAAA,cAAe,IAAA;AACfA,mBAAA,cAAe,IAAA;AAHLA,SAAAA;AAAA,GAAA,mBAAA,CAAA,CAAA;AA0KA,IAAA,iCAAAC,kBAAL;AAELA,gBAAA,UAAW,IAAA;AAEXA,gBAAA,YAAa,IAAA;AAEbA,gBAAA,iBAAkB,IAAA;AAElBA,gBAAA,YAAa,IAAA;AAEbA,gBAAA,aAAc,IAAA;AAEdA,gBAAA,eAAgB,IAAA;AAEhBA,gBAAA,KAAM,IAAA;AAENA,gBAAA,gBAAiB,IAAA;AAhBPA,SAAAA;AAAA,GAAA,gBAAA,CAAA,CAAA;AA8jDL,MAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQzB,MAAM,2BAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmCjC,MAAM,gCAAgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQtC,MAAM,6BAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgEnC,MAAM,6BAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAMnC,MAAM,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgExB,MAAM,8BAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAapC,MAAM,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAe3B,MAAM,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiB5B,MAAM,2BAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+DjC,MAAM,+BAA+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYrC,MAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUzB,MAAM,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAe1B,MAAM,4BAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOlC,MAAM,8BAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUpC,MAAM,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAe3B,MAAM,6BAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQ3B,eAAe;AAAA,EACnB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,0BAA0B;AAAA,EAC1B,6BAA6B;AAAA,EAC7B,0BAA0B;AACO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAc7B,eAAe;AAAA,EACnB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,0BAA0B;AAAA,EAC1B,6BAA6B;AAAA,EAC7B,0BAA0B;AACgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQtC,eAAe;AAAA,EACnB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,0BAA0B;AAAA,EAC1B,6BAA6B;AAAA,EAC7B,0BAA0B;AACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAkD1B,gBAAgB;AACW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQ3B,eAAe;AAAA,EACnB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,0BAA0B;AAAA,EAC1B,6BAA6B;AAAA,EAC7B,0BAA0B;AACO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYQ;AAAA;AAAA;AAAA;AAAA;AAKN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmCL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoCD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAiBzB,eAAe;AAAA,EACnB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,0BAA0B;AAAA,EAC1B,6BAA6B;AAAA,EAC7B,0BAA0B;AAAA,EAC1B,mBAAmB;AAAA,EACnB,kBAAkB;AAAA,EAClB,iBAAiB;AAAA,EACjB,yBAAyB;AACS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAU9B,2BAA2B;AACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2EC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAM1B,wBAAwB;AAAA,EAC5B,2BAA2B;AAAA,EAC3B,mBAAmB;AAAA,EACnB,kBAAkB;AACa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAU3B,wBAAwB;AAAA,EAC5B,2BAA2B;AAAA,EAC3B,mBAAmB;AAAA,EACnB,kBAAkB;AACc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAwD5B,2BAA2B;AAAA,EAC/B,4BAA4B;AAAA,EAC5B,gBAAgB;AAAA,EAChB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,0BAA0B;AAAA,EAC1B,6BAA6B;AAAA,EAC7B,0BAA0B;AAAA,EAC1B,kBAAkB;AACwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAWtC,0BAA0B;AACG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MA2B7B,gBAAgB;AAAA,EACpB,4BAA4B;AAAA,EAC5B,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,0BAA0B;AAAA,EAC1B,6BAA6B;AAAA,EAC7B,0BAA0B;AACK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQlC,mBAAmB;AAAA,EACvB,kBAAkB;AACiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQ/B,eAAe;AAAA,EACnB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,0BAA0B;AAAA,EAC1B,6BAA6B;AAAA,EAC7B,0BAA0B;AACc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQpC,eAAe;AAAA,EACnB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,0BAA0B;AAAA,EAC1B,6BAA6B;AAAA,EAC7B,0BAA0B;AACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYhC,2BAA2B;AACK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}